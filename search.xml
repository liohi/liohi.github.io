<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hive+Hbase 的部署及使用</title>
    <url>/2023/04/24/Hive+Hbase%20%E7%9A%84%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>HBase 和 Hive 是 Hadoop 生态系统中常用的两个组件。HBase 是一个分布式的非关系型数据库，可以用来存储大量的结构化数据；Hive 是一个基于 Hadoop 的数据仓库工具，可以将结构化数据映射为一张数据库表，并提供类似 SQL 的查询语言。</p>
<h4 id="下载-HBase-和-Hive"><a href="#下载-HBase-和-Hive" class="headerlink" title="下载 HBase 和 Hive"></a>下载 HBase 和 Hive</h4><p>注意<code>Hadoop</code> 与 <code>Hbase</code> 和 <code>Hive</code> 的版本匹配问题，不然到后面会有意外惊喜，我的<code>Hadoop</code>是 3.3.4，如果和我一样后面直接复制我的命令即可，不一样你需要去搜一下你版本对应的<code>Hbase</code> 和<code>Hive</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../assets/Hive+Hbase%20%E7%9A%84%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8.assets/version_hbase.png"
                      alt="version_hbase"
                ><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../assets/Hive+Hbase%20%E7%9A%84%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8.assets/version_hive.png"
                      alt="version_hive"
                ></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/local</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 下载</span></span></span><br><span class="line">wget https://mirrors.aliyun.com/apache/hbase/2.5.3/hbase-2.5.3-bin.tar.gz</span><br><span class="line">wget https://mirrors.aliyun.com/apache/hive/hive-3.1.2/apache-hive-3.1.2-bin.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 解压</span></span></span><br><span class="line">tar -zxvf hbase-2.5.3-bin.tar.gz</span><br><span class="line">tar -zxvf apache-hive-3.1.2-bin.tar.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 改一下名字，并将 hive 移动到Hadoop目录下</span></span></span><br><span class="line">mv apache-hive-3.1.2-bin hadoop/hive</span><br><span class="line">mv hbase-2.5.3 hbase</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 修改权限</span></span></span><br><span class="line">sudo chmod -R 777 hbase hadoop/hive</span><br></pre></td></tr></table></figure></div>

<h4 id="配置-HBase"><a href="#配置-HBase" class="headerlink" title="配置 HBase"></a>配置 HBase</h4><p>配置环境变量（顺便把 Hive 的也配置了）</p>
<p><code>$ vi ~/.bashrc</code></p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line">## HBASE_HOME</span><br><span class="line">export HBASE_HOME=/usr/local/hbase</span><br><span class="line">export PATH=$PATH:$HBASE_HOME/bin</span><br><span class="line"></span><br><span class="line">## Hive_HOME</span><br><span class="line">export HIVE_HOME=/usr/local/hadoop/hive</span><br><span class="line">export CLASSPATH=.:$&#123;HIVE_HOME&#125;/lib:$CLASSPATH</span><br><span class="line">export PATH=$&#123;HIVE_HOME&#125;/bin:$&#123;HIVE_HOME&#125;/conf:$PATH</span><br></pre></td></tr></table></figure></div>

<p>生效</p>
<p><code>$ source ~/.bashrc</code></p>
<blockquote>
<p>Hadoop 和 HBase 之间需要进行配置，以便 HBase 可以使用 Hadoop 作为其底层存储和计算引擎</p>
</blockquote>
<ul>
<li><p>将 Hadoop 的 core-site.xml 和 hdfs-site.xml 配置文件复制到 HBase 的 conf 目录下：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cp $HADOOP_HOME/etc/hadoop/core-site.xml $HBASE_HOME/conf/</span><br><span class="line">cp $HADOOP_HOME/etc/hadoop/hdfs-site.xml $HBASE_HOME/conf/</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>编辑 HBase 的 hbase-site.xml 文件：</p>
<p><code>vi /usr/local/hbase/conf/hbase-site.xml</code></p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.rootdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000/hbase<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.cluster.distributed<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>./tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hbase.unsafe.stream.capability.enforce<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h5 id="验证是否启动"><a href="#验证是否启动" class="headerlink" title="验证是否启动"></a>验证是否启动</h5><ul>
<li><p>启动 Hadoop</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">su hadoop</span><br><span class="line"></span><br><span class="line">sudo service ssh start</span><br><span class="line"></span><br><span class="line">ssh localhost</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 启动 Hadoop</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">start-all.sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 启动 HBase</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">start-hbase.sh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看一下</span></span></span><br><span class="line">jps</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../assets/Hive+Hbase%20%E7%9A%84%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8.assets/image-20230420193259179.png"
                      alt="image-20230420193259179"
                ></p>
<p>浏览器访问 Web UI <code>localhost: 16010</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../assets/Hive+Hbase%20%E7%9A%84%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8.assets/image-20230420193400869.png"
                      alt="image-20230420193400869"
                ></p>
<p>则启动成功</p>
</li>
</ul>
<h4 id="配置-Hive"><a href="#配置-Hive" class="headerlink" title="配置 Hive"></a>配置 Hive</h4><p>在将 Hive 与 HBase 集成时需要使用 MySQL 作为元数据存储。Hive 元数据存储在 RDBMS 中，因此需要一个关系型数据库来存储表和列等元数据信息。</p>
<h5 id="配置-mysql（安装好的跳过）"><a href="#配置-mysql（安装好的跳过）" class="headerlink" title="配置 mysql（安装好的跳过）"></a>配置 mysql（安装好的跳过）</h5><ul>
<li><p>安装 mysql 客户端和服务端</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>设置密码</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mysql_secure_installation</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>登录</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mysql -u root -p</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 显示如下则成功</span></span></span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../assets/Hive+Hbase%20%E7%9A%84%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8.assets/image-20230424102437018.png"
                      alt="image-20230424102437018"
                ></p>
</li>
</ul>
<h5 id="配置-Hive-1"><a href="#配置-Hive-1" class="headerlink" title="配置 Hive"></a>配置 Hive</h5><ul>
<li><p>在 Hadoop 集群中创建一个 Hive 元数据存储目录：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hdfs dfs -mkdir /hive</span><br><span class="line">$ hdfs dfs -mkdir /hive/metastore</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>进入 Hive 的 conf 目录</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/hadoop/hive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 将 hive-env.sh.template 复制一份并命名为 hive-env.sh</span></span></span><br><span class="line">cp hive-env.sh.template hive-env.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 编辑hive-env.sh</span></span></span><br><span class="line">vi hive-env.sh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 加上下面配置</span></span></span><br><span class="line">HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export HIVE_CONF_DIR=/usr/local/hadoop/hive/conf</span><br><span class="line">export HIVE_AUX_JARS_PATH=/usr/local/hadoop/hive/lib</span><br></pre></td></tr></table></figure></div>

<ul>
<li>创建一个 hive-site.xml 文件并加上下面配置（<code>vi hive-site.xml</code>）</li>
</ul>
<blockquote>
<p>注意：MySQL5 用的驱动 url 是<code>com.mysql.jdbc.Driver</code>，MySQL6 以后用的是<code>com.mysql.cj.jdbc.Driver</code>。版本不匹配便会报驱动类已过时的错误，所以对应第二个 <code>property</code> 配置应匹配 MySQL 版本</p>
</blockquote>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>jdbc:mysql://localhost:3306/metastore?createDatabaseIfNotExist=true<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hive<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>hive<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.metastore.warehouse.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/user/hive/warehouse<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>hive.exec.local.scratchdir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>/usr/local/hadoop/hive/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>hive 下创建一个 <code>warehouse</code> 和 <code>logs</code>文件夹</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/hive$  mkdir /usr/local/hadoop/hive/warehouse</span><br><span class="line">/hive$  mkdir -p logs</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>hive&#x2F;conf 对 hive-log4j2.properties 配置</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">/hive$ </span><span class="language-bash"> <span class="built_in">cd</span> conf</span></span><br><span class="line"><span class="meta prompt_">/conf$ </span><span class="language-bash"> <span class="built_in">mv</span> hive-log4j2.properties.template hive-log4j2.properties</span></span><br><span class="line"><span class="meta prompt_">/conf$ </span><span class="language-bash"> sudo vi hive-log4j2.properties</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 将第 24 行左右修改（vim 可以直接 :24 跳转到24行）</span></span></span><br><span class="line"></span><br><span class="line">property.hive.log.dir = /usr/local/hadoop/hive/logs</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>进入 hive&#x2F;lib 下面下载 <code>mysql-connector-java</code>的 jar 包，可使用下面命令</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-8.0.27.tar.gz</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 解压</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 将jar 包移动到 hive/lib 目录下，此处省略</span></span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>初始化 metastore 数据库：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">schematool -initSchema -dbType mysql -verbose</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>启动 metastore 服务</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">hive --service metastore</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>另开一个终端</p>
<ul>
<li><p>启动 hive</p>
<p><code>$ hive</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../assets/Hive+Hbase%20%E7%9A%84%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8.assets/image-20230424120736490.png"
                      alt="image-20230424120736490"
                ></p>
</li>
<li><p>创建一个测试表进行测试</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (id <span class="type">INT</span>, name STRING);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;test1&#x27;</span>), (<span class="number">2</span>, <span class="string">&#x27;test2&#x27;</span>), (<span class="number">3</span>, <span class="string">&#x27;test3&#x27;</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../assets/Hive+Hbase%20%E7%9A%84%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8.assets/image-20230424152756644.png"
                      alt="image-20230424152756644"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../assets/Hive+Hbase%20%E7%9A%84%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8.assets/image-20230424152814130.png"
                      alt="image-20230424152814130"
                ><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../assets/Hive+Hbase%20%E7%9A%84%E9%83%A8%E7%BD%B2%E5%8F%8A%E4%BD%BF%E7%94%A8.assets/image-20230424152823200.png"
                      alt="image-20230424152823200"
                ></p>
</li>
<li><p>退出</p>
<p>&gt; <code>exit</code></p>
</li>
<li><p>关闭服务</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">stop-hbase.sh</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">stop-all.sh</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h6 id="至此，Hbase-Hive-配置完成"><a href="#至此，Hbase-Hive-配置完成" class="headerlink" title="至此，Hbase+Hive 配置完成"></a>至此，Hbase+Hive 配置完成</h6>]]></content>
      <categories>
        <category>笔记</category>
        <category>Linux</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 笔记</title>
    <url>/2023/06/03/C++/</url>
    <content><![CDATA[<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> m_x;</span><br><span class="line">	<span class="type">int</span> m_y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Vector</span>(<span class="type">int</span> x,<span class="type">int</span> y) &#123;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_x = x;</span><br><span class="line">		<span class="keyword">this</span>-&gt;m_y = y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 重载 +</span></span><br><span class="line">	Vector <span class="keyword">operator</span>+ (Vector&amp; other) <span class="type">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Vector&#123; m_x + other.m_x,m_y + other.m_y &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Vector&amp; other);	<span class="comment">// 由于重载 &lt;&lt; 函数位于Vector外，访问private 需要private</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 &lt;&lt;</span></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os,<span class="type">const</span> Vector&amp; other) &#123;</span><br><span class="line"></span><br><span class="line">	os &lt;&lt; other.m_x &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; other.m_y &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Vector <span class="title">v1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">	<span class="function">Vector <span class="title">v2</span><span class="params">(<span class="number">1</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">	std::cout &lt;&lt; v1 + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>结果输出：<code>4  8</code></p>
<h2 id="模板template"><a href="#模板template" class="headerlink" title="模板template"></a>模板<code>template</code></h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="type">int</span> size&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T array[size];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Array &lt; std:: string, <span class="number">5</span> &gt; a;</span><br><span class="line">	std::cout &lt;&lt; a.<span class="built_in">getSize</span>()&lt;&lt;std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>结果输出：<code>5</code></p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Value:	&quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values,<span class="type">void</span>(*Print)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> value : values)</span><br><span class="line">		<span class="built_in">Print</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">41</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="built_in">ForEach</span>(values, PrintValue);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>结果输出：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Value:  1</span><br><span class="line">Value:  3</span><br><span class="line">Value:  41</span><br><span class="line">Value:  1</span><br><span class="line">Value:  3</span><br><span class="line">Value:  6</span><br></pre></td></tr></table></figure></div>

<h2 id="lambda-表达式"><a href="#lambda-表达式" class="headerlink" title="lambda 表达式"></a><code>lambda</code> 表达式</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ForEach</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; values,<span class="type">void</span>(*Print)(<span class="type">int</span>))</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> value : values)</span><br><span class="line">		<span class="built_in">Print</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">41</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="keyword">auto</span> it = std::<span class="built_in">find_if</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [](<span class="type">int</span> value) &#123;<span class="keyword">return</span> value &gt; <span class="number">3</span>; &#125;);</span><br><span class="line">	std::cout &lt;&lt; *it &lt;&lt; std::endl;		<span class="comment">// 输出 41</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> lambda = [](<span class="type">int</span> value) &#123;std::cout &lt;&lt; <span class="string">&quot;Value:	&quot;</span> &lt;&lt; value &lt;&lt; std::endl; &#125;;	<span class="comment">//	lambda 表达式</span></span><br><span class="line">	<span class="built_in">ForEach</span>(values, lambda);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">auto</span> lambda = [=](<span class="type">int</span> value) &#123;std::cout &lt;&lt; <span class="string">&quot;Value:	&quot;</span> &lt;&lt; a &lt;&lt; std::endl; &#125;;	<span class="comment">//	lambda 表达式 Capture:&quot;=&quot;</span></span><br><span class="line">	<span class="built_in">ForEach</span>(values, lambda);	<span class="comment">// 输出 5</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a><code>namespace</code></h2><p><code>namespace</code>存在原因：避免命名冲突，在不同的<code>context</code>中使用相同的符号</p>
<p><code>::</code>：名称操作符</p>
<h2 id="thread线程"><a href="#thread线程" class="headerlink" title="thread线程"></a><code>thread</code>线程</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_Finished = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Start thread id is &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl; <span class="comment">//获取线程id</span></span><br><span class="line">	<span class="keyword">while</span> (!s_Finished)</span><br><span class="line">	&#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Working...\n&quot;</span>;</span><br><span class="line">		std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">std::thread <span class="title">worker</span><span class="params">(DoWork)</span></span>;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">	s_Finished = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	worker.<span class="built_in">join</span>();	<span class="comment">// 线程加入</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Finished..\n&quot;</span>;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Start thread id is &quot;</span> &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="计时器-Chrono"><a href="#计时器-Chrono" class="headerlink" title="计时器 Chrono"></a>计时器 <code>Chrono</code></h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span>	<span class="comment">// chrono 计时</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">using</span> <span class="keyword">namespace</span> std::literals::chrono_literals;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s); <span class="comment">// 线程休眠 1s</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">	std::chrono::duration&lt;<span class="type">float</span>&gt; duration = end - start;	<span class="comment">//   计算时间</span></span><br><span class="line">	std::cout &lt;&lt; duration.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;s&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出 ：<code>1.0026s</code></p>
<p>优化…</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;chrono&gt;</span>	<span class="comment">// chrono 计时</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Timer</span></span><br><span class="line">&#123;</span><br><span class="line">	std::chrono::time_point&lt;std::chrono::steady_clock&gt;start, end;</span><br><span class="line">	std::chrono::duration&lt;<span class="type">float</span>&gt;duration;</span><br><span class="line">	<span class="built_in">Timer</span>() &#123;</span><br><span class="line">		start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Timer</span>() &#123;</span><br><span class="line">		end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">		duration = end - start;</span><br><span class="line"></span><br><span class="line">		<span class="type">float</span> ms = duration.<span class="built_in">count</span>() * <span class="number">1000.0f</span>;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;Time took&quot;</span> &lt;&lt; ms &lt;&lt; <span class="string">&quot;ms&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Timer timer;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">		std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">Function</span>();</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">hello</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">hello</span><br><span class="line">Time took 53.99912ms</span><br></pre></td></tr></table></figure></div>

<h2 id="排序Sort"><a href="#排序Sort" class="headerlink" title="排序Sort()"></a>排序<code>Sort()</code></h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; values = &#123; <span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span> &#125;;</span><br><span class="line">	std::<span class="built_in">sort</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), [] (<span class="type">int</span> a,<span class="type">int</span> b) &#123;	<span class="comment">// lambda表达式</span></span><br><span class="line">		<span class="keyword">if</span> (a == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (b == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;	<span class="comment">// 将 1 移到最后</span></span><br><span class="line">		<span class="keyword">return</span> a &lt; b;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> value : values)</span><br><span class="line">		std::cout &lt;&lt; value&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<p><code>2 3 4 5 1</code></p>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><p>移动语义相比于拷贝语义优势在于只用分配一次内存即可访问或者返回对象，减少开辟堆内存时间花销</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Create!\n&quot;</span>);</span><br><span class="line">		m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String&amp; other) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Copyed!\n&quot;</span>);</span><br><span class="line">		m_Size = other.m_Size;</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Data, other.m_Data, m_Size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">String</span>(String&amp;&amp; other) <span class="keyword">noexcept</span>&#123;	<span class="comment">// 移动构造函数</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line">		m_Size = other.m_Size;</span><br><span class="line">		m_Data = other.m_Data;</span><br><span class="line"></span><br><span class="line">		other.m_Size = <span class="number">0</span>;</span><br><span class="line">		other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">String</span>() &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Destroyed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">delete</span> m_Data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++)</span><br><span class="line">			<span class="built_in">putchar</span>(m_Data[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_Data;</span><br><span class="line">	<span class="type">uint32_t</span> m_Size;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entity</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Entity</span>(<span class="type">const</span> String&amp; name)</span><br><span class="line">		:<span class="built_in">m_name</span>(name) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">Entity</span>(String&amp;&amp; name)		<span class="comment">// 接收右值参数</span></span><br><span class="line">		:<span class="built_in">m_name</span>((String&amp;&amp;)name) &#123;	<span class="comment">// 显式声明name为右值传递 或者 :m_name(std::move(name)) 将左值转为右值</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">PrintName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		m_name.<span class="built_in">Print</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	String m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Entity <span class="title">entity</span><span class="params">(<span class="string">&quot;Herrick&quot;</span>)</span></span>;	<span class="comment">// 传递右值参数</span></span><br><span class="line">	entity.<span class="built_in">PrintName</span>();</span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>() = <span class="keyword">default</span>;</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span>* string) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Create!\n&quot;</span>);</span><br><span class="line">		m_Size = <span class="built_in">strlen</span>(string);</span><br><span class="line">		m_Data = <span class="keyword">new</span> <span class="type">char</span>[m_Size];</span><br><span class="line">		<span class="built_in">memcpy</span>(m_Data, string, m_Size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	String&amp; <span class="keyword">operator</span>=(String &amp;&amp;other)<span class="keyword">noexcept</span>&#123;	<span class="comment">// 移动构造函数</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Moved!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">delete</span> m_Data;</span><br><span class="line"></span><br><span class="line">			m_Size = other.m_Size;</span><br><span class="line">			m_Data = other.m_Data;</span><br><span class="line"></span><br><span class="line">			other.m_Size = <span class="number">0</span>;</span><br><span class="line">			other.m_Data = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">String</span>() &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Destroyed!\n&quot;</span>);</span><br><span class="line">		<span class="keyword">delete</span> m_Data;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; m_Size; i++)</span><br><span class="line">			<span class="built_in">putchar</span>(m_Data[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span>* m_Data;</span><br><span class="line">	<span class="type">size_t</span> m_Size;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	String apple = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line">	String dest;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Apple：&quot;</span>;</span><br><span class="line">	apple.<span class="built_in">Print</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Dest:&quot;</span>;</span><br><span class="line">	dest.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">	dest = std::<span class="built_in">move</span>(apple);</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Apple：&quot;</span>;</span><br><span class="line">	apple.<span class="built_in">Print</span>();</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Dest:&quot;</span>;</span><br><span class="line">	dest.<span class="built_in">Print</span>();</span><br><span class="line"></span><br><span class="line">	std::cin.<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Create!</span><br><span class="line">Apple：Apple</span><br><span class="line">Dest:</span><br><span class="line">Moved!</span><br><span class="line">Apple：</span><br><span class="line">Dest:Apple</span><br></pre></td></tr></table></figure></div>

<h2 id="Rule-of-Three"><a href="#Rule-of-Three" class="headerlink" title="Rule of Three"></a>Rule of Three</h2><p>C++三法则（Rule of Three）指的是在定义一个包含动态内存分配的类时，必须重载以下三个函数：</p>
<ol>
<li>拷贝构造函数（Copy Constructor）：用于将一个已存在的对象复制到新创建的对象中。</li>
<li>拷贝赋值操作符（Copy Assignment Operator）：用于将一个已存在的对象赋值给另一个已存在的对象。</li>
<li>析构函数（Destructor）：用于在对象被销毁时释放动态分配的内存。</li>
</ol>
<p>这三个函数的实现都要根据类中的成员变量进行深拷贝或移动操作，否则可能会引起内存泄漏或悬空指针等问题。</p>
<h2 id="Rule-of-Five"><a href="#Rule-of-Five" class="headerlink" title="Rule of Five"></a>Rule of Five</h2><p>C++五法则（Rule of Five）在 C++11 中增加了两个函数，即移动构造函数和移动赋值操作符：</p>
<ol>
<li>拷贝构造函数（Copy Constructor）：用于将一个已存在的对象复制到新创建的对象中。</li>
<li>拷贝赋值操作符（Copy Assignment Operator）：用于将一个已存在的对象赋值给另一个已存在的对象。</li>
<li>移动构造函数（Move Constructor）：用于将一个右值引用的对象移动到新创建的对象中，避免不必要的拷贝开销。</li>
<li>移动赋值操作符（Move Assignment Operator）：用于将一个右值引用的对象赋值给另一个已存在的对象，避免不必要的拷贝开销。</li>
<li>析构函数（Destructor）：用于在对象被销毁时释放动态分配的内存。</li>
</ol>
<p>这五个函数的实现都要根据类中的成员变量进行深拷贝或移动操作，同时避免引起内存泄漏或悬空指针等问题。</p>
<h2 id="顶层-Const-和-底层-Const"><a href="#顶层-Const-和-底层-Const" class="headerlink" title="顶层 Const 和 底层 Const"></a>顶层 <code>Const</code> 和 底层 <code>Const</code></h2><p><strong>概念：</strong></p>
<ul>
<li>顶层<code>Const</code> ，表示修饰的<strong>本身</strong>就是常量，指的是指针，通常 * 右边</li>
<li>底层<code>const</code>，表示修饰的变量所指的量是常量，指的是所指变量，通常 * 左边</li>
</ul>
<p><strong>例：</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;<span class="type">int</span>* <span class="type">const</span> b1 = &amp;a;        <span class="comment">//顶层const，b1本身是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* b2 = &amp;a;       <span class="comment">//底层const，b2本身可变，所指的对象是常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b3 = <span class="number">20</span>; 		   <span class="comment">//顶层const，b3是常量不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="type">const</span> b4 = &amp;a;  <span class="comment">//前一个const为底层，后一个为顶层，b4不可变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; b5 = a;		   <span class="comment">//用于声明引用变量，都是底层const</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>区分作用：</strong></p>
<ul>
<li>执行对象拷贝时有限制，常量的底层 <code>const</code> 不能赋值给非常量的底层 <code>const</code></li>
<li>使用命名的强制类型转换函数 <code>const_cast</code> 时，只能改变运算对象的底层 <code>const</code></li>
</ul>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a;<span class="type">int</span> <span class="type">const</span> a;<span class="type">const</span> <span class="type">int</span> *a;<span class="type">int</span> *<span class="type">const</span> a;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>int const a</code>和<code>const int a</code>均表示定义常量类型 a。</li>
<li><code>const int *a</code>，其中 a 为指向 int 型变量的指针，<code>const</code> 在 * 左侧，表示 a 指向不可变常量。(看成<code> const (*a)</code>，对引用加 <code>const</code> )</li>
<li><code>int *const a</code>，依旧是指针类型，表示 a 为指向整型数据的常指针。(看成 <code>const(a)</code>，对指针 <code>const</code>)</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax</title>
    <url>/2023/04/16/Ajax/</url>
    <content><![CDATA[<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><code>HTTP（HyperText Transport Protocol）</code>协议，也就是超文本传输协议，详细规定了浏览器和万维网服务器之间相互通信的规则</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>格式与参数</p>
<div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">行	POST /s?ie=utf<span class="number">-8</span> HTTP/<span class="number">1.1</span></span><br><span class="line">头	HOST<span class="punctuation">:</span> herrick<span class="number">.3</span>vhost.net</span><br><span class="line">	 Cookie<span class="punctuation">:</span> name=herrick</span><br><span class="line">	 Content-type<span class="punctuation">:</span> application/x-www-form-urlencoded</span><br><span class="line">	 User-Agent<span class="punctuation">:</span> chorome<span class="number">-83</span></span><br><span class="line">空行</span><br><span class="line">体</span><br></pre></td></tr></table></figure></div>

<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><div class="highlight-container" data-rel="Json"><figure class="iseeu highlight json"><table><tr><td class="code"><pre><span class="line">行	HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">头	Content-Type<span class="punctuation">:</span> text/html;charset=utf<span class="number">-8</span></span><br><span class="line">	 Content-length<span class="punctuation">:</span> <span class="number">2048</span></span><br><span class="line">	 Content-encoding<span class="punctuation">:</span> gzip</span><br><span class="line">空行</span><br><span class="line">体	&lt;html&gt;</span><br><span class="line">		&lt;head&gt;</span><br><span class="line">		&lt;/head&gt;</span><br><span class="line">		&lt;body&gt;</span><br><span class="line">			&lt;h1&gt;标题&lt;/h1&gt;</span><br><span class="line">		&lt;/body&gt;</span><br><span class="line">	&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>404</li>
<li>403</li>
<li>401</li>
<li>500 ……</li>
</ul>
<h3 id="express-框架"><a href="#express-框架" class="headerlink" title="express 框架"></a>express 框架</h3><p><code>express</code>框架是一个简介而灵活的<code>node.js</code> <code>Web</code>应用框架，提供了一系列强大的特性创建各种 Web 应用和丰富的<code>HTTP</code>工具。</p>
<p>使用<code>express</code>框架可以快速搭建一个完整功能的网站，所以我们可以利用<code>express</code>模拟一个后端服务的环境</p>
<ul>
<li><p>首先在项目包里利用<code>npm</code>下载<code>express</code></p>
</li>
<li><pre><code>npm i express
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 创建一个`server.js`文件</span><br><span class="line"></span><br><span class="line">- ```javascript</span><br><span class="line">  //引入express</span><br><span class="line">  const &#123; response &#125; = require(&quot;express&quot;);</span><br><span class="line">  const express = require(&quot;express&quot;);</span><br><span class="line"></span><br><span class="line">  //创建应用对象</span><br><span class="line">  const app = express();</span><br><span class="line"></span><br><span class="line">  //创建路由规则</span><br><span class="line">  //request对请求报文封装</span><br><span class="line">  //respose对相应报文封装</span><br><span class="line">  app.get(&quot;/&quot;, (request, response) =&gt; &#123;</span><br><span class="line">    //设置响应</span><br><span class="line">    response.send(&quot;hello express&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  app.listen(8000, () =&gt; &#123;</span><br><span class="line">    console.log(&quot;服务已经启动,8000端口监听中....&quot;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></div>
</code></pre>
</li>
<li><p>然后<code>node server.js</code>,注意路径需要<code>cd</code>到当前包下</p>
</li>
</ul>
<p>此时服务已经启动，控制台显示<code>服务已经启动,8000端口监听中....</code>,网址输入<code>localhost:8000</code>能够看到<code>hello express</code></p>
<h3 id="原生-Ajax"><a href="#原生-Ajax" class="headerlink" title="原生 Ajax"></a>原生 Ajax</h3><p>创建两个文件，一个<code>HTML</code>和一个<code>server.js</code></p>
<p><code>server.js</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//.创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//.创建路由规则</span></span><br><span class="line"><span class="comment">//request对请求报文封装</span></span><br><span class="line"><span class="comment">//respose对相应报文封装</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/server&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头，设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&quot;hello express&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//.监听端口启动服务</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;服务已经启动,8000端口监听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><code>.html</code></p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>AJAX GEt 请求<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>点击发送请求<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[if lt IE 7]&gt;</span></span><br><span class="line"><span class="comment">      &lt;p class=&quot;browsehappy&quot;&gt;</span></span><br><span class="line"><span class="comment">        You are using an &lt;strong&gt;outdated&lt;/strong&gt; browser. Please</span></span><br><span class="line"><span class="comment">        &lt;a href=&quot;#&quot;&gt;upgrade your browser&lt;/a&gt; to improve your experience.</span></span><br><span class="line"><span class="comment">      &lt;/p&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//获取button元素</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;button&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="comment">//绑定时间</span></span></span><br><span class="line"><span class="language-javascript">      btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//1.创建对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//2.初始化，设置请求方法和 url</span></span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:8000/server&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//3.发送</span></span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//4.事件绑定 处理服务端返回的结果</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// on when 当……的时候</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//readystate 是 xhr 对象中的属性，表示状态0 1 2 3 4</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//change 改变</span></span></span><br><span class="line"><span class="language-javascript">        xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="comment">//判断</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//判断响应状态码 200 404 403 401 500</span></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//2** 成功</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">              <span class="comment">//处理结果 行 头 空行 体</span></span></span><br><span class="line"><span class="language-javascript">              <span class="comment">//1.响应行</span></span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">status</span>); <span class="comment">//状态码</span></span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">statusText</span>); <span class="comment">//状态字符串</span></span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="title function_">getAllResponseHeaders</span>()); <span class="comment">//所有响应头</span></span></span><br><span class="line"><span class="language-javascript">              <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">response</span>); <span class="comment">//响应体</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">              result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;test&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#result</span> &#123;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">      <span class="attribute">border</span>: solid <span class="number">1px</span> black;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>实现效果如下：</p>
<p>点击发送请求会在显示框内打印出响应体，同时在控制台显示请求信息</p>
<p>以上就完成了一个简单的<code>GET</code>请求</p>
<p>接下来向服务端发起一个<code>POST</code>请求</p>
<p>满足需求是：当鼠标移到显示框的时候，显示框能显示到服务端发来的响应体</p>
<p>修改<code>HTML</code>文件</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 7]&gt;      &lt;html class=&quot;no-js lt-ie9 lt-ie8 lt-ie7&quot;&gt; &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 7]&gt;         &lt;html class=&quot;no-js lt-ie9 lt-ie8&quot;&gt; &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 8]&gt;         &lt;html class=&quot;no-js lt-ie9&quot;&gt; &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if gt IE 8]&gt;      &lt;html class=&quot;no-js&quot;&gt; &lt;!--&lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br><span class="line">        AJAX GEt 请求</span><br><span class="line">    <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span></span><br><span class="line">        点击发送请求</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;result&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[if lt IE 7]&gt;</span></span><br><span class="line"><span class="comment">            &lt;p class=&quot;browsehappy&quot;&gt;You are using an &lt;strong&gt;outdated&lt;/strong&gt; browser. Please &lt;a href=&quot;#&quot;&gt;upgrade your browser&lt;/a&gt; to improve your experience.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">        &lt;![endif]--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;result&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        result.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://localhost:8000/server&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">            xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-id">#result</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: solid <span class="number">1px</span> black;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>但是此时如果将鼠标移动到框内，控制台会报错<code>No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</code>因为服务段没有与之匹配的响应规则。此时服务端的规则还是上一小节的<code>GET</code>，所以需要向服务端<code>server.js</code>添加以下规则：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;/server&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头，设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  response.<span class="title function_">send</span>(<span class="string">&quot;hello express&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>重新启动服务<code> node server.js</code>,再次在<code>html</code>页面滑动鼠标到框内，显示响应体成功</p>
<h4 id="POST-请求设置参数"><a href="#POST-请求设置参数" class="headerlink" title="POST 请求设置参数"></a>POST 请求设置参数</h4><p><code>POST</code>请求设置参数，请求体是在<code>send()</code>里设置的，参数的形式任意，但是需要服务端能够处理</p>
<p>比如<code>xhr.send(&#39;a=100&amp;b=200&amp;c=300&#39;)</code>，或者可以<code>xhr.send(&#39;a:100&amp;b:200&amp;c:300&#39;)</code>,或者直接<code>xhr.send(&#39;12341414141&#39;)</code>，只要服务端能够处理就可</p>
<h3 id="Ajax-设置请求头信息"><a href="#Ajax-设置请求头信息" class="headerlink" title="Ajax 设置请求头信息"></a>Ajax 设置请求头信息</h3><p>设置请求信息，只需要在<code>open</code>()后面调用一个方法<code>setRequestHeader</code>例如</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  result.<span class="title function_">addEventListener</span>(<span class="string">&quot;mousemove&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">    xhr.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;http://localhost:8000/server&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//其中Content-Type是设置请求体内容的类型，后面的内容是参数查询字符串的类型，固定写法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//比如可以自己设定一个头信息</span></span></span><br><span class="line"><span class="language-javascript">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;herrick.3vhost&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h3 id="服务端响应json数据"><a href="#服务端响应json数据" class="headerlink" title="服务端响应json数据"></a>服务端响应<code>json</code>数据</h3><p>实际工作中服务端返回数据多数情况都是以<code>json</code>格式发送，那么返回的结果应该怎么处理很重要</p>
<p>首先向<code>server.js</code>添加下面代码<code>all</code>代表接收所有类型的请求</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">all</span>(<span class="string">&quot;/json-server&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头，设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;herrick&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//由于send只能发送jsom或者bufferl类型，所以需要对字符串进行一个转换</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  response.<span class="title function_">send</span>(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><code>html</code>文件<code>&lt;script&gt;</code>标签内容如下</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">const</span> result = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;result&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//绑定键盘按下时间</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onkeydown</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//发送请求</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//初始化;</span></span></span><br><span class="line"><span class="language-javascript">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:8000/json-server&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//发送</span></span></span><br><span class="line"><span class="language-javascript">    xhr.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//事件绑定</span></span></span><br><span class="line"><span class="language-javascript">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (xhr.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; xhr.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">          result.<span class="property">innerHTML</span> = xhr.<span class="property">response</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>当键盘按下之后，就能接收到服务端传来的<code>json</code>数据</p>
<p>此时数据为一个<code>json</code>格式字符串，我们需要将其变成一个对象</p>
<p>可以手动转换</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">let data = JSON.parse(xhr.response); //然后就可以使用data里面的数据</span><br><span class="line">result.innerHTML = data.name;</span><br></pre></td></tr></table></figure></div>

<p>更推荐自动转换</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">xhr.responseType = &#x27;json&#x27; //然后就可以直接使用数据 result.innerHTML =</span><br><span class="line">xhr.response.name</span><br></pre></td></tr></table></figure></div>

<h3 id="nodemon-工具"><a href="#nodemon-工具" class="headerlink" title="nodemon 工具"></a><code>nodemon</code> 工具</h3><p>作用：自动检测文件改变重启服务</p>
<p>前提：<code>node.js</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g nodemon</span><br><span class="line">//再使用nodemon重启服务</span><br><span class="line">nodemon server.js</span><br><span class="line">//部分用户会出现错误&lt; nodemon : 无法加载文件XXX，因为在此系统上禁止运行脚本。&gt;原因是powershell权限不够</span><br><span class="line">//解决方法</span><br><span class="line">1. win+R输入powershell</span><br><span class="line">2. 输入start-proces s PowerShell -verb runas 进入管理员权限</span><br><span class="line">3. 管理员身份输入set-Exe cutionPolicy RemoteSigned 选择y</span><br><span class="line">4. 再次nodemon server.js 服务启动</span><br><span class="line"></span><br><span class="line">nodemon启动服务后修改服务端代码后就无需重启服务</span><br></pre></td></tr></table></figure></div>

<h3 id="Ajax-IE-缓存问题解决"><a href="#Ajax-IE-缓存问题解决" class="headerlink" title="Ajax-IE 缓存问题解决"></a>Ajax-IE 缓存问题解决</h3><p>问题描述：IE 浏览器会对 Ajax 的请求结果做一个缓存，导致再次发送请求时走的时本地缓存而不是服务器返回的数据，导致最新数据不能接收。</p>
<p>解决方案：修改<code>open()</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.open(&#x27;GET&#x27;, &#x27;http://localhost:8000/json-server?t=&#x27;+Date.now);</span><br><span class="line">// Date.now是一个时间戳，所以每次都会发送不同请求，浏览器就会判定为两次请求，也就解决了缓存问题</span><br></pre></td></tr></table></figure></div>

<h3 id="Ajax-请求超时和网络异常"><a href="#Ajax-请求超时和网络异常" class="headerlink" title="Ajax 请求超时和网络异常"></a>Ajax 请求超时和网络异常</h3><p>例如：请求两秒为超时</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//超时时间为2s</span><br><span class="line">xhr.timeout = 2000;</span><br><span class="line">//超时回调</span><br><span class="line">xhr.ontimeout = function()&#123;</span><br><span class="line">	alert(&quot;网络超时，请稍后重试！&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//异常回调</span><br><span class="line">xhr.onerror = function()&#123;</span><br><span class="line">	alert(&quot;网络异常！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Ajax-取消请求"><a href="#Ajax-取消请求" class="headerlink" title="Ajax 取消请求"></a>Ajax 取消请求</h3><p>调用<code>XMLHttpRequest</code>的<code>abort()</code></p>
<p>例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//按下按键取消请求</span><br><span class="line">btn.onclick = function()&#123;</span><br><span class="line">	xhr.abort();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="Ajax-重复发送请求"><a href="#Ajax-重复发送请求" class="headerlink" title="Ajax 重复发送请求"></a>Ajax 重复发送请求</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">let</span> isSending = <span class="literal">false</span>;	<span class="comment">//是否正在发送Ajax请求</span></span><br><span class="line">	btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isSending)x.<span class="title function_">abort</span>();	<span class="comment">//如果正在发送，则取消该请求，创建一个新的请求</span></span><br><span class="line">        x = <span class="keyword">new</span> <span class="title class_">XMLHttpRrequest</span>();</span><br><span class="line">        isSending = <span class="literal">true</span>;</span><br><span class="line">        x.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>,<span class="string">&quot;http://localhost:8000&quot;</span>);</span><br><span class="line">        x.<span class="title function_">send</span>();</span><br><span class="line">        x.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x.<span class="property">readyState</span> === <span class="number">4</span>)&#123;</span><br><span class="line">                isSending = <span class="literal">false</span>;	<span class="comment">//修改标识变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="Axios发送Ajax请求"><a href="#Axios发送Ajax请求" class="headerlink" title="Axios发送Ajax请求"></a><code>Axios</code>发送<code>Ajax</code>请求</h3><ul>
<li>首先配置<code>server.js</code></li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//axios 服务</span></span><br><span class="line">app.<span class="title function_">all</span>(<span class="string">&quot;/axios-server&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//设置响应头，设置允许跨域</span></span><br><span class="line">  response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">//设置响应体</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;herrick&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//由于send只能发送jsom或者bufferl类型，所以需要对字符串进行一个转换</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data);</span><br><span class="line">  response.<span class="title function_">send</span>(str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>HTML</code>引用<code>Axios</code>资源</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">  crossorigin=<span class="string">&quot;anonymous&quot;</span></span><br><span class="line">  src=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.1.3/axios.js&quot;</span></span><br><span class="line">&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><h4 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a><code>GET</code>请求</h4></li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;button&#x27;</span>); btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span></span><br><span class="line">  (<span class="params"></span>)&#123;<span class="string">&quot; &quot;</span>&#125;</span><br><span class="line">  &#123;axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8000/axios-server&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">//url 参数</span></span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="attr">vip</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>此时控制台可以看到传递的参数</p>
<ul>
<li></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS 文件读写</title>
    <url>/2023/04/15/HDFS%20%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<h4 id="启动-HDFS"><a href="#启动-HDFS" class="headerlink" title="启动 HDFS"></a>启动 HDFS</h4><ul>
<li><p>进入 hadoop 用户</p>
<p><code>su hadoop</code></p>
</li>
<li><p>启动 SSH 服务</p>
<p><code>sudo service ssh start</code></p>
</li>
<li><p>连接 localhost</p>
<p><code>ssh localhost</code></p>
</li>
<li><p>开启服务</p>
<p><code>start-all.sh</code></p>
</li>
<li><p>查看</p>
<p><code>jps</code></p>
<p>出现以下信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../my_imgs/hdfs1.png"
                      alt="hdfs1"
                ></p>
<p>表示启动成功</p>
</li>
</ul>
<h4 id="准备测试文件"><a href="#准备测试文件" class="headerlink" title="准备测试文件"></a>准备测试文件</h4><p>创建一个工作文件夹</p>
<p><code>$ sudo mkdir /usr/local/hadoop/hadoop-demo</code></p>
<p>进入工作文件夹</p>
<p><code>$ cd /usr/local/hadoop/hadoop-demo</code></p>
<p>创建一个测试文件 testfile，大小 1G</p>
<p><code>$ dd if=/dev/zero of=testfile bs=1M count=1024</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../my_imgs/hdfs2.png"
                      alt="hdfs2"
                ></p>
<h4 id="HDFS-读文件"><a href="#HDFS-读文件" class="headerlink" title="HDFS 读文件"></a>HDFS 读文件</h4><ul>
<li><p>进入 hadoop 目录</p>
<p><code>$ cd /usr/local/hadoop</code></p>
</li>
<li><p>创建 hadoop 工作文件夹</p>
<p><code>hadoop fs -mkdir /test1</code></p>
</li>
<li><p>获取 hadoop 集群报告</p>
<p><code>$ hdfs dfsadmin -report</code></p>
</li>
<li><p>上传本地文件（读）</p>
<p><code>$./bin/hdfs dfs -put /usr/local/hadoop/hadoop-demo/testfile /test1</code></p>
</li>
<li><p>查看</p>
<p><code>$  hadoop fs -ls /test1</code></p>
</li>
</ul>
<h4 id="HDFS-写文件"><a href="#HDFS-写文件" class="headerlink" title="HDFS 写文件"></a>HDFS 写文件</h4><ul>
<li><p>本地创建一个输出文件夹</p>
<p><code>$ sudo mkdir /usr/local/hadoop/hadoop-demo/out</code></p>
</li>
<li><p>写入文件</p>
<p><code>$ ./bin/hdfs dfs -get /test1/testfile /usr/local/hadoop/hadoop-demo/out</code></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../my_imgs/hdfs3.png"
                      alt="hdfs3"
                ></p>
<p>最终将<code>testfile</code>写入<code>/out</code>文件夹</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../my_imgs/hdfs4.png"
                      alt="hdfs4"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../my_imgs/hdfs5.png"
                      alt="hdfs5"
                ></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Linux</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 单机配置 Hadoop 环境</title>
    <url>/2023/04/16/Ubuntu%20%E5%8D%95%E6%9C%BA%E9%85%8D%E7%BD%AE%20Hadoop/</url>
    <content><![CDATA[<ul>
<li><p>创建<code>Hadoop</code>用户</p>
<p><code> sudo useradd -m hadoop -s /bin/bash</code></p>
</li>
<li><p>设置<code>Hadoop</code>密码</p>
<p><code>sudo passwd hadoop</code></p>
</li>
<li><p>为<code>Hadoop</code>用户增加管理员权限</p>
<p><code>sudo adduser hadoop sudo</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../my_imgs/hadoop1.png"
                      alt="hadoop1"
                ></p>
</li>
<li><h3 id="安装配置SSH"><a href="#安装配置SSH" class="headerlink" title="安装配置SSH"></a>安装配置<code>SSH</code></h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install ssh</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">su hadoop</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -P <span class="string">&quot;&quot;</span></span></span><br><span class="line"></span><br><span class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></div>

<p>接下来运行 ssh 命令,测试一下是否成功.</p>
<p><code>$ ssh localhost</code></p>
</li>
<li><h3 id="配置java环境"><a href="#配置java环境" class="headerlink" title="配置java环境"></a>配置<code>java</code>环境</h3></li>
</ul>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get update</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt-get install default-jdk</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><h3 id="安装hadoop"><a href="#安装hadoop" class="headerlink" title="安装hadoop"></a>安装<code>hadoop</code></h3><ul>
<li>下载 hadoop</li>
</ul>
<p>清华镜像源：<a class="link"   href="https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/" >https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><code>wget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.3.4/hadoop-3.3.4.tar.gz </code></p>
<ul>
<li><p>配置环境变量</p>
<p>将<code>Hadoop</code>文件解压并移动到 <code>/usr/local/hadoop</code> 文件夹下</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf hadoop-3.3.4.tar.gz</span><br><span class="line">sudo mv hadoop-3.3.4 /usr/local/hadoop</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在<code>terminal</code>中输入 <code>sudo vi ~/.bashrc</code> ，按 <strong>i</strong> 进入编辑模式：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/local/hadoop</span><br><span class="line">export HADOOP_INSTALL=$HADOOP_HOME</span><br><span class="line">export HADOOP_MAPRED_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_COMMON_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_HDFS_HOME=$HADOOP_HOME</span><br><span class="line">export YARN_HOME=$HADOOP_HOME</span><br><span class="line">export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</span><br><span class="line">export HADOOP_OPTS=&quot;-Djava.library.path=$HADOOP_HOME/lib/native&quot;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../my_imgs/hadoop2.png"
                      alt="hadoop2"
                ></p>
</li>
<li><h3 id="修改Hadoop配置文件"><a href="#修改Hadoop配置文件" class="headerlink" title="修改Hadoop配置文件"></a>修改<code>Hadoop</code>配置文件</h3><p>打开 <code>/usr/local/hadoop/etc/hadoop/</code> 文件夹：</p>
<ul>
<li><p>配置 <code>hadoop-env.sh</code> 文件</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显式声明java路径</span></span><br><span class="line">export JAVA_HOME=/usr/lib/jvm/java</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>配置<code>~/.bashrc</code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">#<span class="variable constant_">HADOOP</span> <span class="variable constant_">VARIABLES</span> <span class="variable constant_">START</span></span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">JAVA_HOME</span>=<span class="regexp">/usr/</span>lib/jvm/java</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">HADOOP_INSTALL</span>=<span class="regexp">/usr/</span>local/hadoop</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">PATH</span>=<span class="attr">$PATH</span>:$HADOOP_INSTALL/bin</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">PATH</span>=<span class="attr">$PATH</span>:$HADOOP_INSTALL/sbin</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">HADOOP_MAPRED_HOME</span>=$HADOOP_INSTALL</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">HADOOP_COMMON_HOME</span>=$HADOOP_INSTALL</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">HADOOP_HDFS_HOME</span>=$HADOOP_INSTALL</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">YARN_HOME</span>=$HADOOP_INSTALL</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">HADOOP_COMMON_LIB_NATIVE_DIR</span>=$HADOOP_INSTALL/lib/native</span><br><span class="line"><span class="keyword">export</span> <span class="variable constant_">HADOOP_OPTS</span>=<span class="string">&quot;-Djava.library.path=$HADOOP_INSTALL/lib/native&quot;</span></span><br><span class="line">#<span class="variable constant_">HADOOP</span> <span class="variable constant_">VARIABLES</span> <span class="variable constant_">END</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>配置 <code>core-site.xml</code> 文件</p>
<p>在修改这个文件之前，我们需要使用超级用户创建一个目录，并给予<code>hadoop</code>该目录的权限：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">mkdir</span> -p /app/hadoop/tmp</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> hadoop:hadoop /app/hadoop/tmp</span></span><br></pre></td></tr></table></figure></div>

<p>接下来切换回<code>hadoop</code>用户，修改配置文件，文件路径：<code>/usr/local/hadoop/etc/hadoop/core-site.xml</code>，使用 VI，将配置改为：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>/app/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>A base for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.default.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:54310<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>The name of the default file system.  A URI whose</span><br><span class="line">  scheme and authority determine the FileSystem implementation.  The</span><br><span class="line">  uri&#x27;s scheme determines the config property (fs.SCHEME.impl) naming</span><br><span class="line">  the FileSystem implementation class.  The uri&#x27;s authority is used to</span><br><span class="line">  determine the host, port, etc. for a filesystem.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>修改<code>mapred-site.xml</code></p>
<p><code>vi  /usr/local/hadoop/etc/hadoop/mapred-site.xml</code></p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapred.job.tracker<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost:54311<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>The host and port that the MapReduce job tracker runs</span><br><span class="line">  at.  If &quot;local&quot;, then jobs are run in-process as a single map</span><br><span class="line">  and reduce task.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>修改<code>hdfs-site.xml</code></p>
<p>在修改之前，需要切换回超级管理员账户，创建需要用到的目录</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">mkdir</span> -p /usr/local/hadoop_store/hdfs/namenode</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">mkdir</span> -p /usr/local/hadoop_store/hdfs/datanode</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chown</span> -R hduser:hadoop /usr/local/hadoop_store</span></span><br></pre></td></tr></table></figure></div>

<p>然后切换回来<code>hadoop</code>用户，修改配置文件：<code>/usr/local/hadoop/etc/hadoop/hdfs-site.xml</code>，改为：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">  &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">  &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">  &lt;description&gt;Default block replication.</span><br><span class="line">  The actual number of replications can be specified when the file is created.</span><br><span class="line">  The default is used if replication is not specified in create time.</span><br><span class="line">  &lt;/description&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">   &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">   &lt;value&gt;file:/usr/local/hadoop_store/hdfs/namenode&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">   &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">   &lt;value&gt;file:/usr/local/hadoop_store/hdfs/datanode&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>格式化<code>HDFS</code></p>
<p><code>hadoop namenode –format</code></p>
</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../my_imgs/hadoop3.png"
                      alt="hadoop3"
                ></p>
<ul>
<li><p>启动<code>Hadoop</code></p>
<p>设置无密码登录</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line">chmod 755 ~/.ssh</span><br><span class="line"></span><br><span class="line">cd ~/.ssh</span><br><span class="line"></span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure></div>

<p>连接本地</p>
<p><code>ssh localhost</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../my_imgs/hadoop4.png"
                      alt="hadoop4"
                ></p>
<p>启动：</p>
<p><code> start-all.sh</code></p>
<p>查看服务：</p>
<p><code>jps</code></p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../my_imgs/hadoop5.png"
                      alt="hadoop5"
                ></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Linux</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce 基础操作</title>
    <url>/2023/04/20/MapReduce%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h6 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h6><p><code>MapReduce</code>是一种分布式计算框架，用于处理大规模数据集的计算问题。它是由 Google 公司开发的，旨在简化并行计算的开发。</p>
<p>在<code>MapReduce</code>中，计算问题被分解成两个阶段：映射（<code>Map</code>）和归约（<code>Reduce</code>）。映射阶段将输入数据划分成小的数据块，并将每个数据块映射到一组键值对。然后，这些键值对被传递给归约阶段，归约阶段对键值对进行分组，并对每组执行归约操作，生成最终结果。</p>
<p><code>MapReduce</code>的优点是它可以在大规模计算集群上高效地并行运行，而无需开发人员关心底层的并发细节。这使得开发人员可以更专注于算法设计和问题解决，而不是处理并发和分布式系统的复杂性。</p>
<h5 id="前提：确保配置好-Hadoop-环境"><a href="#前提：确保配置好-Hadoop-环境" class="headerlink" title="前提：确保配置好 Hadoop 环境"></a>前提：确保配置好 Hadoop 环境</h5><p>其中 MapReduce 对应 <code>&lt;HADOOP_HOME&gt;/etc/hadoop/mapred_site.xml</code>配置文件：</p>
<p>（我的<code>HADOOP_HOME</code>是<code>/usr/local/hadoop</code>则对应）</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mapred_site.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.app.mapreduce.am.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/usr/local/hadoop<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.map.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/usr/local/hadoop<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.reduce.env<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>HADOOP_MAPRED_HOME=/usr/local/hadoop<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><ul>
<li><p>进入 Hadoop 用户（取决于个人配置，没添加用户就不用）</p>
<p><code>$ su hadoop</code></p>
</li>
<li><p>启动 ssh</p>
<p><code>$ sudo service ssh start</code></p>
</li>
<li><p>链接本地服务</p>
<p><code>$ ssh localhost</code></p>
</li>
<li><p>启动服务</p>
<p><code>$ start-all.sh</code></p>
</li>
<li><p>jps 查看，显示如下则启动成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../assets/Map%20Reduce%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE.assets/image-20230419161304679.png"
                      alt="image-20230419161304679"
                ></p>
</li>
</ul>
<h4 id="编写-WordCount-java"><a href="#编写-WordCount-java" class="headerlink" title="编写 WordCount.java"></a>编写 WordCount.java</h4><ul>
<li><p>创建工作文件夹</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> /usr/local/hadoop</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">mkdir</span> hadoop-demo</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">chmod</span> -R 777 hadoop-demo <span class="comment"># 修改权限</span></span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>编写 <code>WordCount.java</code></p>
<p><code>$ vi WordCOunt.java</code></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.IntWritable;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.io.Text;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Job;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.Reducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.input.FileInputFormat;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordCount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TokenizerMapper</span></span><br><span class="line">            <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;Object, Text, Text, IntWritable&gt;&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">IntWritable</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Text</span> <span class="variable">word</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Text</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">map</span><span class="params">(Object key, Text value, Context context</span></span><br><span class="line"><span class="params">        )</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">            <span class="type">StringTokenizer</span> <span class="variable">itr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(value.toString());</span><br><span class="line">            <span class="keyword">while</span> (itr.hasMoreTokens()) &#123;</span><br><span class="line">                word.set(itr.nextToken());</span><br><span class="line">                context.write(word, one);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">IntSumReducer</span></span><br><span class="line">            <span class="keyword">extends</span> <span class="title class_">Reducer</span>&lt;Text,IntWritable,Text,IntWritable&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">IntWritable</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntWritable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values,</span></span><br><span class="line"><span class="params">                           Context context</span></span><br><span class="line"><span class="params">        )</span> <span class="keyword">throws</span> IOException, InterruptedException &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (IntWritable val : values) &#123;</span><br><span class="line">                sum += val.get();</span><br><span class="line">            &#125;</span><br><span class="line">            result.set(sum);</span><br><span class="line">            context.write(key, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">conf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>();</span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> Job.getInstance(conf, <span class="string">&quot;word count&quot;</span>);</span><br><span class="line">        job.setJarByClass(WordCount.class);</span><br><span class="line">        job.setMapperClass(TokenizerMapper.class);</span><br><span class="line">        job.setCombinerClass(IntSumReducer.class);</span><br><span class="line">        job.setReducerClass(IntSumReducer.class);</span><br><span class="line">        job.setOutputKeyClass(Text.class);</span><br><span class="line">        job.setOutputValueClass(IntWritable.class);</span><br><span class="line">        FileInputFormat.addInputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">0</span>]));</span><br><span class="line">        FileOutputFormat.setOutputPath(job, <span class="keyword">new</span> <span class="title class_">Path</span>(args[<span class="number">1</span>]));</span><br><span class="line">        System.exit(job.waitForCompletion(<span class="literal">true</span>) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="打包成-JAR-文件"><a href="#打包成-JAR-文件" class="headerlink" title="打包成 JAR 文件"></a>打包成 JAR 文件</h4><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">/hadoop-demo</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> classes</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">javac -classpath <span class="variable">$&#123;HADOOP_CLASSPATH&#125;</span> -d classes WordCount.java</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">jar -cvf wordcount.jar -C classes/ .</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>若出现 <code>error: package org.apache.hadoop.conf does not exist</code>等错误可能是 <code>Hadoop</code>环境变量没配好</p>
<p>解决：</p>
<ul>
<li><p><code>sudo vi ~/.bashrc</code></p>
</li>
<li><p>添加以下行</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># HADOOP_HOME</span></span></span><br><span class="line">export HADOOP_HOME=/path/to/hadoop</span><br><span class="line">export HADOOP_CLASSPATH=$($HADOOP_HOME/bin/hadoop classpath)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>source ~/.bashrc</code></p>
</li>
</ul>
</blockquote>
<h4 id="创建测试文件并运行"><a href="#创建测试文件并运行" class="headerlink" title="创建测试文件并运行"></a>创建测试文件并运行</h4><ul>
<li><p>创建一个&#96;input.txt&#96;&#96;</p>
<p><code>vi input.txt</code></p>
</li>
<li><p>随便写点东西…（推荐写几个重复的单词，空格分开，这样结果更直观）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bulabulabula 不啦不啦</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>将 input.txt 上传到 HDFS 文件系统 (HDFS 文件读写搜索历史文章有介绍)</p>
<p><code>$ hdfs dfs -put input.txt /test1</code></p>
</li>
<li><p>提交 MapReduce 作业</p>
<p><code>$ hadoop jar wordcount.jar WordCount /test1 /output</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../assets/Map%20Reduce%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE.assets/image-20230420111459501.png"
                      alt="image-20230420111459501"
                ></p>
</li>
<li><p>将 output 从 HDFS 系统提取出来</p>
<p><code> hdfs dfs -get /output out</code></p>
</li>
<li><p>查看一下</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> out</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 可以看到_SUCCESS 和part_r_00000</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vi part_r_00000</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/../assets/Map%20Reduce%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE.assets/image-20230420121625841.png"
                      alt="image-20230420121625841"
                ></p>
<p>两个单词分别 1 个(当然在测试文件里可以创建几个重复的单词更直观)</p>
</li>
</ul>
<h6 id="Over"><a href="#Over" class="headerlink" title="Over!"></a>Over!</h6>]]></content>
      <categories>
        <category>笔记</category>
        <category>Linux</category>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript 学习笔记</title>
    <url>/2023/04/16/javascript%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 一个script标签就是一个代码段--&gt;</span><br><span class="line">&lt;!-- 每一个代码段之间相互独立，如果上面代码段报错，不会影响下面代码段--&gt;</span><br><span class="line"><span class="comment">//第一个代码段</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> a=<span class="number">1</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//输出a;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//使用了未声明的变量，报错 c is not defined</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">//报错</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//ReferenceError 引用错误</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//对于引用错误来说，统统一个代码段如果报了引用错误，错误下面代码就停止执行</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个代码段</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> b=<span class="number">2</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//上面代码段定义的数据，下面代码段也可以使用，但是下面代码段定义数据不可以在上面使用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="预编译（预解析）"><a href="#预编译（预解析）" class="headerlink" title="预编译（预解析）"></a>预编译（预解析）</h3><p>JS 代码在执行时可分为两个阶段</p>
<ol>
<li>预编译（预解析）</li>
<li>代码执行，即一行一行执行，等到解析结束之后，才会尽心那个代码执行，也就是说浏览器把 JS 代码进行加工之后再去执行，加工的过程就是预编译</li>
</ol>
<p>预编译期间做了什么？</p>
<ol>
<li>声明提升：<code>var</code>变量提升，但是之提升了声明没有赋值。<code>function</code>函数整体提升。提升到代码段最前面</li>
<li>如果在函数内部的局部变量，就提升但函数内部的最前面</li>
</ol>
<blockquote>
<p><strong>ps：var 变量只提升声明，函数提升的是函数整体</strong></p>
</blockquote>
<h3 id="代码执行产生-EC-和-GO"><a href="#代码执行产生-EC-和-GO" class="headerlink" title="代码执行产生 EC 和 GO"></a>代码执行产生 EC 和 GO</h3><p>JS 在内存中主要看内存的栈区和堆区，其中基本数据类型存储在栈区，引用数据类型（函数）存储在堆区，地址存储在栈区</p>
<p>JS 代码主要分两类</p>
<p>全局代码：默认进入<code>script</code>标签就会执行全局代码</p>
<p>函数代码：一个函数就是一个局部函数代码</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//a和b位于全局代码</span></span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> b=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//c和d位于局部代码</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> c=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">var</span> d=<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>全局代码执行时，会产生全局执行上下文<code>Execution Context Globle(ECG)</code></li>
<li>每调用函数时就产生一个局部的执行上下文</li>
<li>执行上下文产生即放入一个栈空间：执行上下文栈<code>Execution Context Stack(ECS)</code></li>
<li>当函数调用完毕，函数的<code>EC</code>出栈，当<code>ECG</code>执行完毕，<code>ECG</code>也要出栈</li>
</ul>
<p>执行上下文<code>EC</code>的作用：给代码提供数据，代码中需要的数据都从<code>EC</code>中的栈中读取</p>
<p>JS 代码在执行时。会在堆内存中创建一个全局对象<code>Global Object(GO)</code>，这个<code>GO</code>也就是<code>Window</code>，是一个全局对象，对象也就是属性的无序集合。很多<code>API</code>都是<code>Window</code>的属性，例如：<code>Date,Array,String,Number,SetTimeout...</code></p>
<ul>
<li><p>执行全局代码时会在<code>ECS</code>中产生<code>ECG</code> ，在堆内存则会有一个<code>GO(Window)</code></p>
</li>
<li><p>代码执行前<code>ECG</code>中包含两个部分：</p>
<ul>
<li>变量对象<code>VO</code>（此时就等同于<code>GO</code>）</li>
<li>全局代码执行</li>
</ul>
</li>
<li><p>调用函数<code>fn()</code>时，产生一个<code>EC(fn)</code>入栈，包含三个部分</p>
<ul>
<li><p>解析函数称为<code>AST</code>树结构时，会创建一个活动对象<code>Activation Object(AO)</code>,<code>AO</code>中包含形参、arguments、函数定义和指向函数对象、定义的变量</p>
</li>
<li><p>作用域链<code>scopchain</code>：由<code>VO</code>（在函数中就是<code>AO</code>的对象）和父级<code>VO</code>组成，查找时会逐层查找。ps：所谓作用域链就是数据在<code>EC</code>中查找的过程，找一个数据，先在自己的<code>EC</code>中找，如果找不到就去父的<code>EC</code>中找，直到<code>ECG</code>，如果还找不到就报错。</p>
</li>
<li><p><code>this</code>绑定的值</p>
</li>
</ul>
</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">//代码执行前存在GO：包含内置属性和自定义的全局变量和全局函数 var n=1;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">//去执行上下文（ECG）中寻找n，ECG中有VO，也就是GO，GO中有n</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">n</span>); <span class="comment">//直接去GO中找n m=2; console.log(m);</span></span><br><span class="line">  <span class="comment">//ECG中找m，GO中有m console.log(x); //ECG中找不到x，x is not define</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">name</span>(name); <span class="comment">//虽然没有自定义name变量，但是GO中内置属性有name</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="再来个栗子"><a href="#再来个栗子" class="headerlink" title="再来个栗子"></a>再来个栗子</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//代码执行产生ECS</span></span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">1</span>;	<span class="comment">//全局代码执行产生ECG,ECG里有VO，也就是GO，a存入到栈区</span></span><br><span class="line">	<span class="keyword">var</span> b=<span class="number">2</span>;	<span class="comment">//b和a同样存入到栈区</span></span><br><span class="line"></span><br><span class="line">	funtion <span class="title function_">fn</span>(<span class="params"></span>)&#123;	<span class="comment">//fn函数体存在堆区，函数地址存在栈区</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> arr=[<span class="string">&quot;1&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>];	<span class="comment">//数组与函数类似，地址存在栈区，数组体存在堆区</span></span><br><span class="line">	<span class="keyword">var</span> obj=&#123;<span class="attr">name</span>:<span class="string">&quot;老八&quot;</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="变量和闭包"><a href="#变量和闭包" class="headerlink" title="变量和闭包"></a><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img1.png"
                      alt="img1"
                >变量和闭包</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><blockquote>
<p>加 var 和不加 var 的变量区别</p>
</blockquote>
<p>需要注意的是：</p>
<ul>
<li>加<code>var</code>的变量在预编译的期间会提升，但是不加<code>var</code>的变量在预编译的时候不会提升</li>
<li>不管是否加<code>var</code>，只要是全局变量，在非严格模式下都会挂载到<code>GO</code>上</li>
<li>加<code>var</code>的变量既可以做全局变量也可以局部变量，不加<code>var</code>只能全局变量</li>
</ul>
<p>平时做项目基本不用<code>var</code>，更不要不定义变量类型</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="comment">//虽然有变量提升，但是var只提升了定义，并没有赋值所以应该是undefined var a=1;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//此时a被赋值为1所以应该输出1 console.log(window.a);</span></span><br><span class="line">  <span class="comment">//a挂载到GO上，所以在逐层访问的时候能够访问到，下面的b同理 // console.log(b);</span></span><br><span class="line">  <span class="comment">//会输出undefined b=2; console.log(window.b);</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>使用 let 声明变量</p>
</blockquote>
<p>使用<code>let</code>声明的变量没有提升，或者可以理解为变量提升了，但是没有赋值，也就是不能直接访问</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//ReferenceError: Cannot access &#x27;a&#x27; before initialization let</span></span><br><span class="line">  a=<span class="number">2</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p><code>let+&#123;&#125;</code>可以形成块级作用域，块级作用域中定义的变量，只能在块中使用</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> b=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);     <span class="comment">//  1</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);     <span class="comment">//Uncaught ReferenceError: b is not defined</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>使用<code>let</code>声明的变量，并不会挂载到<code>GO</code>上</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="keyword">let</span> a=<span class="number">1</span>; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>); <span class="comment">//undefined&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></div>

<p><code>let</code>不能重复声明</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">let</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> a=<span class="number">1</span>;	<span class="comment">//报错，a不能重复声明</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//形参相当于函数内部定义的局部变量</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//VO：AO已经有a，也会报错</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//Uncaught SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">let</span> a=<span class="number">1</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">fn</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<p>所以项目中声明变量基本使用<code>let</code>，弥补了<code>var</code>声明变量的缺点</p>
<blockquote>
<p>使用 const 声明变量（常量）的特点</p>
</blockquote>
<ul>
<li>声明不能被修改</li>
<li>使用<code>const</code>声明变量时，必须赋值，不然会报语法错误</li>
<li><code>const</code> 声明的变量也不会提升</li>
<li><code>const</code> 和<code>&#123;&#125;</code>也可以形成块级作用域</li>
<li><code>const</code> 声明的变量也不会挂载到<code>GO</code>上</li>
</ul>
<blockquote>
<p>总结：在项目中，定义变量用 let，定义常量用 const</p>
</blockquote>
<h5 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h5><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(fn);     <span class="comment">//  打印undefine</span></span><br><span class="line">   <span class="comment">//window.fn();     //   报错fn is not a function</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">fn</span>);  <span class="comment">//undefine fn说明挂载到了GO</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(<span class="string">&quot;fn&quot;</span><span class="keyword">in</span> <span class="variable language_">window</span>)&#123;   <span class="comment">//满足条件</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_">fn</span>();       <span class="comment">//.....</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    函数位于if条件中，</span></span><br><span class="line"><span class="comment">    在最新版本的浏览器中，不会提升整体，只会提升fn函数名</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">fn</span>();        <span class="comment">//.....</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"> <span class="title function_">fn</span>();  <span class="comment">//最后一次函数提升是打印5，所以输出5</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);&#125; <span class="comment">//函数提升，打印1</span></span><br><span class="line"> <span class="title function_">fn</span>();  <span class="comment">//打印5</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);&#125;<span class="comment">//函数再提升，覆盖1，打印2</span></span><br><span class="line"> <span class="title function_">fn</span>();  <span class="comment">//打印5</span></span><br><span class="line"> <span class="keyword">var</span> fn =<span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);&#125;<span class="comment">//函数名提升，相当于赋值</span></span><br><span class="line"> <span class="title function_">fn</span>();  <span class="comment">//打印3</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);&#125; <span class="comment">//函数提升打印4</span></span><br><span class="line"> <span class="title function_">fn</span>();  <span class="comment">//打印3</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);&#125;<span class="comment">//函数提升打印5</span></span><br><span class="line"> <span class="title function_">fn</span>();  <span class="comment">//打印3</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> a=<span class="number">1</span>;b=<span class="number">2</span>;c=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>)&#123;     <span class="comment">//相当于函数局部变量a</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c); <span class="comment">//先找函数执行上下文，传入了20则a=20,b=2,c-3</span></span><br><span class="line">        a=<span class="number">100</span>;</span><br><span class="line">        b=<span class="number">200</span>;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c); <span class="comment">//a被赋值为100，b为200，c：4</span></span><br><span class="line">    &#125;</span><br><span class="line">    b=<span class="title function_">fn</span>(<span class="number">20</span>);   <span class="comment">//b为undefined</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a,b,c); <span class="comment">//log:  1 undefined 3</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>先看代码</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">A</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">x</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="title function_">A</span>();</span><br><span class="line">    <span class="title function_">y</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">B</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">20</span>;</span><br><span class="line">        <span class="title function_">y</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">B</span>();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p>画出部分堆栈图</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/img2.png"
                      alt="img2"
                ></p>
<blockquote>
<p>按照堆栈函数调用来说，当 A 函数调用完毕，ECA 出栈，ECA 中分配的占内存，也就是 i，需要回收。但是，由于 ECG 中的一个 y，引用着这个 0x345 的堆空间，0x345 堆空间中存在着 ECA 中 i 的栈空间，所以说，0x345 这个堆和 ECA 中的 i 是不能被释放。一个不能被回收释放掉的栈空间，叫做闭包，i 会常驻内存，会造成内存空间泄露。</p>
</blockquote>
<p>然后再调用函数 y，执行上下文<code>ECy</code>入栈<code>console.log(y)</code>，所以再去作用域链里寻找<code>i</code>，作用域链里包含自身<code>VO</code>和父<code>VO</code>，最终在父<code>VO</code>里找到<code>i</code>为<code>2</code> 输出。调用之后，出栈销毁。</p>
<p>然后调用函数<code>B</code>，执行上下文<code>ECB</code>，包含<code>VO：AO</code>，ｉ的值为<code>20</code>，然后调用ｙ又产生一个执行上下文<code>ECy2</code>，<code>ECy2</code>中只有<code>console.log</code>(i)，所以在作用域链中寻找，在父<code>VO</code>中找到<code>i=2</code></p>
<p>所以最终控制台输出 2 2</p>
<blockquote>
<p>闭包：一个不能被回收的栈内存，就可以被成为闭包</p>
<p>作用：</p>
<ul>
<li>保护 EC 中的变量，外界不能直接访问</li>
<li>可以让我们像使用全局变量一样使用局部变量，延长了变量的生命周期</li>
</ul>
</blockquote>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p><code>this</code>：字面意思是“这个”的意思</p>
<blockquote>
<p><code>this</code>和书写的位置没有关系，和调用的方式有关系，是产生执行上下文<code>EC</code>的时候动态绑定的</p>
<p><code>this</code>的绑定规则：</p>
<ul>
<li>默认绑定</li>
<li>隐式绑定</li>
<li>显式绑定</li>
<li><code>new</code>绑定</li>
</ul>
</blockquote>
<h4 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h4><p>独立函数调用就是所谓的默认绑定，独立的函数调用我们可以理解成函数没有被绑定到某个对象上进行调用</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn</span>();<span class="comment">//独立函数调用,函数内部的this表示window</span></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!----------------------------------------&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">//window</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">gn</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">//window</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        fn;     <span class="comment">//独立函数调用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">kn</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  <span class="comment">//window</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="title function_">gn</span>();   <span class="comment">//独立函数调用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">kn</span>();<span class="comment">//独立函数调用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!----------------------------------------&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> obj = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>:<span class="string">&quot;老八&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">fn</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> gn= obj.<span class="property">fn</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">gn</span>();   <span class="comment">//独立函数调用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!----------------------------------------&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> o=&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>:<span class="string">&quot;老八&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">fun</span>:fun</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> gn=obj,fn;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="title function_">gn</span>();       <span class="comment">//独立函数调用</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>以上<code>this</code>指向的都是<code>window</code></p>
<h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><p>另外一种比较常见的调用方式是通过某个对象进行调用的，他就是它的调用位置中，是通过某个对象发起的函数调用</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;老八&quot;</span>,</span><br><span class="line">        <span class="attr">fn</span>: fn</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过obj打点调用，fn中this表示什么，</span></span><br><span class="line">    <span class="comment">//就看点前面是什么，点前面是obj，this就是obj</span></span><br><span class="line">    obj.<span class="title function_">fn</span>();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台输出：&#123;name:&#x27;老八&#x27;,fn: f&#125;</span></span><br></pre></td></tr></table></figure></div>

<h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p><code>JS</code>中，函数有多种角色</p>
<ul>
<li>普通函数</li>
<li>对象中的方法</li>
<li>对象（属性的无序集合，内部有很多默认属性和方法，<code>call,apply,bind...</code>）</li>
<li>类（构造器，构造函数）</li>
</ul>
<p><code>call()</code></p>
<ul>
<li>显示绑定<code>this</code></li>
<li>让<code>fn()</code>执行</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, num1 + num2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;zy&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//call()从第二个参数开始，开始传递参数给函数</span></span><br><span class="line">    fn.<span class="title function_">call</span>(fn, <span class="number">222</span>, <span class="number">333</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//独立调用函数 this表示window</span></span><br><span class="line">    <span class="title function_">fn</span>();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<p><code>apply()</code></p>
<p><code>apply</code>作用和<code>call</code>一样，传参方式不同，需要把参数放到一个数组</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.<span class="title function_">apply</span>(obj, [<span class="number">222</span>, <span class="number">333</span>]);</span><br></pre></td></tr></table></figure></div>

<p><code>bind()</code></p>
<p>作用和<code>call()</code>一样但是不会让函数执行，返回<code>this</code>之后的新函数</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newFn = fn.<span class="title function_">bind</span>(obj, <span class="number">222</span>, <span class="number">333</span>);</span><br><span class="line"><span class="title function_">newFn</span>();</span><br></pre></td></tr></table></figure></div>

<h5 id="显式绑定总结："><a href="#显式绑定总结：" class="headerlink" title="显式绑定总结："></a>显式绑定总结：</h5><ul>
<li><code>call fn.call(obj,1,2)</code> 显式绑定<code>this</code>,让<code>fn()</code>执行 ，也能传参</li>
<li><code>apply fn.apply(obj,[1,2])</code> 显式绑定 <code>this</code>，让<code>fn()</code>执行，参数放到数组中</li>
<li><code>bind fn.bind(obj,1,2)</code> 显式绑定<code>this</code>，返回绑定<code>this</code>后的新函数，也能传参</li>
</ul>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// String&#123;&#x27;hello&#x27;&#125;是一个对象，</span></span><br><span class="line"><span class="comment">// 会拿hello包装成一个对象</span></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//一项两种实际上是绑定到了window上</span></span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">undefined</span>);</span><br><span class="line">fn.<span class="title function_">call</span>(<span class="literal">null</span>);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="new-绑定"><a href="#new-绑定" class="headerlink" title="new 绑定"></a>new 绑定</h4><p><code>JS</code>中，函数有多种角色</p>
<ul>
<li>普通函数</li>
<li>对象中的方法</li>
<li>函数也是对象</li>
<li>函数也是类（构造函数&#x2F;构造器），通常情况下首字母大写</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//定义一个类，Person，构造器、构造函数</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//new在函数内部创建了一个对象</span></span><br><span class="line">        <span class="comment">//把函数内的this绑定到了对象上</span></span><br><span class="line">        <span class="comment">//函数执行</span></span><br><span class="line">        <span class="comment">//返回这个对象(new完后，肯定是得到一个对象)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//this指向对象</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;xdec&quot;</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//new一个类。得到一个对象</span></span><br><span class="line">    <span class="keyword">let</span> p2=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xxx&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p1);</span><br><span class="line">    <span class="comment">//控制台:  Person&#123;name:xxx,age:1&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每new一次就创建出一个新的对象</span></span><br><span class="line">    <span class="keyword">let</span> p3=<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;yyy&quot;</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p2);</span><br><span class="line">    <span class="comment">//控制台：  Person&#123;name:yyy,age:3&#125;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="this-绑定的优先级"><a href="#this-绑定的优先级" class="headerlink" title="this 绑定的优先级"></a>this 绑定的优先级</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);    <span class="comment">// 定时器中的this表示window</span></span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//监听器中的this表示事件源</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="comment">//控制台输出 &lt;button id=&quot;btn&quot;&gt;按钮&lt;/button&gt;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>默认绑定的优先级最低</li>
<li>显示绑定的优先级高于隐式绑定</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">        <span class="comment">//显式绑定</span></span><br><span class="line">        <span class="attr">fn</span>: fn.<span class="title function_">bind</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;yyy&quot;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//隐式绑定</span></span><br><span class="line">    obj.<span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最终控制台输出&#123;name:&#x27;yyy&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>new 绑定优先级高于隐式绑定</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   <span class="keyword">let</span> obj = &#123;</span><br><span class="line">       <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">       <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">           <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> res = <span class="keyword">new</span> obj.<span class="title function_">fn</span>();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//最终控制台输出	fn&#123;&#125;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>new 绑定高于显式绑定</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> gn = fn.<span class="title function_">bind</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span> &#125;)</span><br><span class="line">    <span class="comment">//  gn();       //&#123;name:&#x27;xxx&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title function_">gn</span>();       <span class="comment">//fn&#123;&#125;</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>new 绑定不能和 call 和 apply 比较</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = fn.<span class="title function_">call</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span> &#125;)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title function_">res</span>();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> <span class="title function_">foo</span> = (<span class="params">nums</span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> nums * <span class="number">2</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果形参只有一个，那么()可以不写</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> <span class="title function_">foo</span> = nums =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">return</span> nums * <span class="number">2</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果函数体只有一条语句，那么&#123;&#125;和return 都可以不写</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> <span class="title function_">foo</span> = nums =&gt; nums * <span class="number">2</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果函数只有一条语句并且返回一个对象</span></span><br><span class="line"><span class="comment">// 需要将对象()起来</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> <span class="title function_">foo</span> = a =&gt; (&#123; <span class="attr">a</span>: <span class="number">32131</span> &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  没有形参，()不能省略</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">     <span class="keyword">var</span> <span class="title function_">foo</span> = (<span class="params"></span>) =&gt; (&#123; <span class="attr">a</span>: <span class="number">32131</span> &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h4 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h4><p>箭头函数中的 this 需要往上找一层</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">gn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显式绑定</span></span><br><span class="line">    gn.<span class="title function_">call</span>(obj);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制台输出 window</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">let</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    fn.<span class="title function_">call</span>(<span class="string">&quot;hello&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    fn.<span class="title function_">call</span>(&#123;&#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">//返回的都是window</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">var</span> obj = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">fn</span>: <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    obj.<span class="title function_">fn</span>();</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// window</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;, <span class="number">2000</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 没用箭头函数的时候指向window</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 使用箭头函数之后还是指向window</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>html<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>css<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>js<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 得到一个伪数组，伪数组不是数组，是对象</span></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">//  &#123;0:&quot;a&quot;,2:&quot;b&quot;,3:&quot;c&quot;&#125;伪数组</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> lis = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(lis[<span class="number">0</span>]);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">dir</span>(lis[<span class="number">0</span>]);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>

<p>一个真实的<code>dom</code>元素，本质就是一个对象，这个对象的属性非常多，操作这个对象，性能就很低，由此<code>JQuery</code>被取代，<code>JQuery</code>操作的就是<code>DOM</code>元素，<code>vue、react</code>操作的就是虚拟<code>DOM</code>元素，虚拟<code>DOM</code>元素的属性灭有那么多</p>
<h4 id="new-的原理"><a href="#new-的原理" class="headerlink" title="new 的原理"></a>new 的原理</h4><p><code>new</code>做了什么：</p>
<ul>
<li>在构造器内部创建一个新的对象</li>
<li>这个歌对象的<code>prototype</code>属性会被复制为该构造函数的<code>prototype</code>属性</li>
<li>让构造器中的<code>this</code>指向这个对象</li>
<li>执行构造器中的代码</li>
<li>如果构造器中没有返回对象，则返回上面创建出来的对象</li>
</ul>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数在JS中有多种角色，其中一种角色就是构造器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fn...&quot;</span>);</span><br><span class="line">  <span class="comment">//1.创建一个新的对象</span></span><br><span class="line">  <span class="comment">//2.让函数中的this绑定到这个新对象上(new绑定)</span></span><br><span class="line">  <span class="comment">//3.执行类（函数）中的代码</span></span><br><span class="line">  <span class="comment">//4.返回上面的新对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br></pre></td></tr></table></figure></div>

<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><h4 id="公有属性和私有属性"><a href="#公有属性和私有属性" class="headerlink" title="公有属性和私有属性"></a>公有属性和私有属性</h4><p>只要是一个对象，身上必定有一个属性叫<code>__proto__</code>，<code>__proto__</code>是属性名，叫隐式原型</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">obj是一个对象，对象是属性的无序集合，属性又分为两类：</span></span><br><span class="line"><span class="comment">	1.私有属性</span></span><br><span class="line"><span class="comment">	2.公有属性	沿着__proto__找到的属性都是公有属性</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>, <span class="comment">//私有属性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//obj. 找hanOwnProperty，自己私有属性没有，就沿着__proto__去公有属性找</span></span><br><span class="line"><span class="comment">//只有找到了这个属性或方法，才能使用这个属性或方法</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>());</span><br></pre></td></tr></table></figure></div>

<p><code>a.b</code></p>
<p>先去自己的<code>EC</code>（执行上下文）中找<code>a</code>，如果找不到，就去父的<code>EC</code>中找，如果还找不到，就去父的父中找，直到找到<code>ECG</code>（全局执行上下文），如果还找不到，<code>error: a is not defined</code>，整个查找机制就叫做作用域链。</p>
<p>找<code>b</code>，先找自己的私有属性，如果找不到，就沿<code>__proto__</code>去公有属性中找，如果公有属性一直找不到，得到<code>undefined</code>，因为查找一个对象上不存在的属性，得到<code>undefined</code>，叫原型链</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;xxx&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//__proto__对应的值是一个对象，这个对象，叫做原型对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//obj.__proto__ 对应的是原型对象</span></span><br><span class="line"><span class="comment">//hasOwnProperty 相对于原型对象来说,是私有属性</span></span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//原型对象，也是对象，只要是一个对象，身上都有一个__proto__</span></span><br><span class="line"><span class="comment">//如果一直找下去，就找到了null</span></span><br><span class="line"><span class="comment">// console.log(obj.__proto__.__proto__);</span></span><br></pre></td></tr></table></figure></div>

<h6 id="in"><a href="#in" class="headerlink" title="in"></a>in</h6><p>判断一个属性是否的呼吁某个对象（私有、公有）</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;push&quot;</span> <span class="keyword">in</span> arr); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></div>

<h6 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h6><p>判断是否是私有</p>
<h4 id="隐式原型和显式原型"><a href="#隐式原型和显式原型" class="headerlink" title="隐式原型和显式原型"></a>隐式原型和显式原型</h4><h6 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h6><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;wc&quot;</span>, <span class="string">&quot;xq&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span> == arr1.<span class="property">__proto__</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1.<span class="property">__proto__</span>.<span class="property">__proto__</span> == <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1.<span class="property">__proto__</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span>); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure></div>

<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>作用域链：是在<code>EC</code>中查找数据的机制</p>
<p>原型链：实在对象上查找属性的机制</p>
<h5 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h5><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;xxx&quot;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">__proto__</span>.<span class="property">constructor</span> == <span class="title class_">Person</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">100</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="property">__proto__</span>.<span class="property">constructor</span> == <span class="title class_">Number</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></div>

<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li>一切都是对象</li>
<li>对象是属性的无序集合</li>
<li>属性分为公有属性和私有属性</li>
<li>每个对象身上都有一个<code>__proto__</code>(隐式原型)</li>
<li>每个函数身上都有一个<code>prototype</code>(显式原型)</li>
<li>对象的隐式原型和函数的显式原型，指向一个对象，叫做原型对象</li>
<li>每一个原型对象身上有一个<code>constructor</code>属性指向函数本身</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2023/06/03/Vue/</url>
    <content><![CDATA[<h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules
├── public
│   ├── favicon.ico: 页签图标
│   └── index.html: 主页面
├── src
│   ├── assets: 存放静态资源
│   │   └── logo.png
│   │── component: 存放组件
│   │   └── HelloWorld.vue
│   │── App.vue: 汇总所有组件
│   │── main.js: 入口文件
├── .gitignore: git版本管制忽略的配置
├── babel.config.js: babel的配置文件
├── package.json: 应用包配置文件
├── README.md: 应用描述文件
├── package-lock.json：包版本控制文件
</code></pre>
<h2 id="关于不同版本的-Vue"><a href="#关于不同版本的-Vue" class="headerlink" title="关于不同版本的 Vue"></a>关于不同版本的 Vue</h2><ol>
<li>vue.js 与 vue.runtime.xxx.js 的区别：<ol>
<li>vue.js 是完整版的 Vue，包含：核心功能 + 模板解析器。</li>
<li>vue.runtime.xxx.js 是运行版的 Vue，只包含：核心功能；没有模板解析器。</li>
</ol>
</li>
<li>因为 vue.runtime.xxx.js 没有模板解析器，所以不能使用 template 这个配置项，需要使用 render 函数接收到的 createElement 函数去指定具体内容。</li>
</ol>
<h2 id="vue-config-js-配置文件"><a href="#vue-config-js-配置文件" class="headerlink" title="vue.config.js 配置文件"></a>vue.config.js 配置文件</h2><ol>
<li>使用 vue inspect &gt; output.js 可以查看到 Vue 脚手架的默认配置。</li>
<li>使用 vue.config.js 可以对脚手架进行个性化定制，详情见：<a class="link"   href="https://cli.vuejs.org/zh" >https://cli.vuejs.org/zh <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
<h2 id="ref-属性"><a href="#ref-属性" class="headerlink" title="ref 属性"></a>ref 属性</h2><ol>
<li>被用来给元素或子组件注册引用信息（id 的替代者）</li>
<li>应用在 html 标签上获取的是真实 DOM 元素，应用在组件标签上是组件实例对象（vc）</li>
<li>使用方式：<ol>
<li>打标识：<code>&lt;h1 ref=&quot;xxx&quot;&gt;.....&lt;/h1&gt;</code> 或 <code>&lt;School ref=&quot;xxx&quot;&gt;&lt;/School&gt;</code></li>
<li>获取：<code>this.$refs.xxx</code></li>
</ol>
</li>
</ol>
<h2 id="props-配置项"><a href="#props-配置项" class="headerlink" title="props 配置项"></a>props 配置项</h2><ol>
<li><p>功能：让组件接收外部传过来的数据</p>
</li>
<li><p>传递数据：<code>&lt;Demo name=&quot;xxx&quot;/&gt;</code></p>
</li>
<li><p>接收数据：</p>
<ol>
<li><p>第一种方式（只接收）：<code>props:[&#39;name&#39;] </code></p>
</li>
<li><p>第二种方式（限制类型）：<code>props:&#123;name:String&#125;</code></p>
</li>
<li><p>第三种方式（限制类型、限制必要性、指定默认值）：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">props</span>:&#123;</span><br><span class="line">	<span class="attr">name</span>:&#123;</span><br><span class="line">	<span class="attr">type</span>:<span class="title class_">String</span>, <span class="comment">//类型</span></span><br><span class="line">	<span class="attr">required</span>:<span class="literal">true</span>, <span class="comment">//必要性</span></span><br><span class="line">	<span class="attr">default</span>:<span class="string">&#x27;老王&#x27;</span> <span class="comment">//默认值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<blockquote>
<p>备注：props 是只读的，Vue 底层会监测你对 props 的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制 props 的内容到 data 中一份，然后去修改 data 中的数据。</p>
</blockquote>
</li>
</ol>
<h2 id="mixin-混入"><a href="#mixin-混入" class="headerlink" title="mixin(混入)"></a>mixin(混入)</h2><ol>
<li><p>功能：可以把多个组件共用的配置提取成一个混入对象</p>
</li>
<li><p>使用方式：</p>
<p>第一步定义混合：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    data()&#123;....&#125;,</span><br><span class="line">    methods:&#123;....&#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>第二步使用混入：</p>
<p>​ 全局混入：<code>Vue.mixin(xxx)</code><br>​ 局部混入：<code>mixins:[&#39;xxx&#39;]	</code></p>
</li>
</ol>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ol>
<li><p>功能：用于增强 Vue</p>
</li>
<li><p>本质：包含 install 方法的一个对象，install 的第一个参数是 Vue，第二个以后的参数是插件使用者传递的数据。</p>
</li>
<li><p>定义插件：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">对象.<span class="property">install</span> = <span class="keyword">function</span> (<span class="params">Vue, options</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 添加全局过滤器</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">filter</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 添加全局指令</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 配置全局混入(合)</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(....)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 添加实例方法</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;...&#125;</span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$myProperty</span> = xxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用插件：<code>Vue.use()</code></p>
</li>
</ol>
<h2 id="scoped-样式"><a href="#scoped-样式" class="headerlink" title="scoped 样式"></a>scoped 样式</h2><ol>
<li>作用：让样式在局部生效，防止冲突。</li>
<li>写法：<code>&lt;style scoped&gt;</code></li>
</ol>
<h2 id="总结-TodoList-案例"><a href="#总结-TodoList-案例" class="headerlink" title="总结 TodoList 案例"></a>总结 TodoList 案例</h2><ol>
<li><p>组件化编码流程：</p>
<p>​ (1).拆分静态组件：组件要按照功能点拆分，命名不要与 html 元素冲突。</p>
<p>​ (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：</p>
<p>​ 1).一个组件在用：放在组件自身即可。</p>
<p>​ 2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。</p>
<p>​ (3).实现交互：从绑定事件开始。</p>
</li>
<li><p>props 适用于：</p>
<p>​ (1).父组件 &#x3D;&#x3D;&gt; 子组件 通信</p>
<p>​ (2).子组件 &#x3D;&#x3D;&gt; 父组件 通信（要求父先给子一个函数）</p>
</li>
<li><p>使用 v-model 时要切记：v-model 绑定的值不能是 props 传过来的值，因为 props 是不可以修改的！</p>
</li>
<li><p>props 传过来的若是对象类型的值，修改对象中的属性时 Vue 不会报错，但不推荐这样做。</p>
</li>
</ol>
<h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><ol>
<li><p>存储内容大小一般支持 5MB 左右（不同浏览器可能还不一样）</p>
</li>
<li><p>浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。</p>
</li>
<li><p>相关 API：</p>
<ol>
<li><p><code>xxxxxStorage.setItem(&#39;key&#39;, &#39;value&#39;);</code><br>该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。</p>
</li>
<li><p><code>xxxxxStorage.getItem(&#39;person&#39;);</code></p>
<p>​ 该方法接受一个键名作为参数，返回键名对应的值。</p>
</li>
<li><p><code>xxxxxStorage.removeItem(&#39;key&#39;);</code></p>
<p>​ 该方法接受一个键名作为参数，并把该键名从存储中删除。</p>
</li>
<li><p><code> xxxxxStorage.clear()</code></p>
<p>​ 该方法会清空存储中的所有数据。</p>
</li>
</ol>
</li>
<li><p>备注：</p>
<ol>
<li>SessionStorage 存储的内容会随着浏览器窗口关闭而消失。</li>
<li>LocalStorage 存储的内容，需要手动清除才会消失。</li>
<li><code>xxxxxStorage.getItem(xxx)</code>如果 xxx 对应的 value 获取不到，那么 getItem 的返回值是 null。</li>
<li><code>JSON.parse(null)</code>的结果依然是 null。</li>
</ol>
</li>
</ol>
<h2 id="组件的自定义事件"><a href="#组件的自定义事件" class="headerlink" title="组件的自定义事件"></a>组件的自定义事件</h2><ol>
<li><p>一种组件间通信的方式，适用于：<strong style="color:red">子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件</strong></p>
</li>
<li><p>使用场景：A 是父组件，B 是子组件，B 想给 A 传数据，那么就要在 A 中给 B 绑定自定义事件（<span style="color:red">事件的回调在 A 中</span>）。</p>
</li>
<li><p>绑定自定义事件：</p>
<ol>
<li><p>第一种方式，在父组件中：<code>&lt;Demo @atguigu=&quot;test&quot;/&gt;</code> 或 <code>&lt;Demo v-on:atguigu=&quot;test&quot;/&gt;</code></p>
</li>
<li><p>第二种方式，在父组件中：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> ref=<span class="string">&quot;demo&quot;</span>/&gt;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">xxx</span>.$on(<span class="string">&#x27;atguigu&#x27;</span>,<span class="variable language_">this</span>.<span class="property">test</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>若想让自定义事件只能触发一次，可以使用<code>once</code>修饰符，或<code>$once</code>方法。</p>
</li>
</ol>
</li>
<li><p>触发自定义事件：<code>this.$emit(&#39;atguigu&#39;,数据)</code></p>
</li>
<li><p>解绑自定义事件<code>this.$off(&#39;atguigu&#39;)</code></p>
</li>
<li><p>组件上也可以绑定原生 DOM 事件，需要使用<code>native</code>修饰符。</p>
</li>
<li><p>注意：通过<code>this.$refs.xxx.$on(&#39;atguigu&#39;,回调)</code>绑定自定义事件时，回调<span style="color:red">要么配置在 methods 中</span>，<span style="color:red">要么用箭头函数</span>，否则 this 指向会出问题！</p>
</li>
</ol>
<h2 id="全局事件总线（GlobalEventBus）"><a href="#全局事件总线（GlobalEventBus）" class="headerlink" title="全局事件总线（GlobalEventBus）"></a>全局事件总线（GlobalEventBus）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>安装全局事件总线：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线，$bus就是当前应用的vm</span></span><br><span class="line">	&#125;,</span><br><span class="line">    ......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用事件总线：</p>
<ol>
<li><p>接收数据：A 组件想接收数据，则在 A 组件中给$bus 绑定自定义事件，事件的<span style="color:red">回调留在 A 组件自身。</span></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&#x27;xxxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>提供数据：<code>this.$bus.$emit(&#39;xxxx&#39;,数据)</code></p>
</li>
</ol>
</li>
<li><p>最好在 beforeDestroy 钩子中，用$off 去解绑<span style="color:red">当前组件所用到的</span>事件。</p>
</li>
</ol>
<h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><ol>
<li><p>一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。</p>
</li>
<li><p>使用步骤：</p>
<ol>
<li><p>安装 pubsub：<code>npm i pubsub-js</code></p>
</li>
<li><p>引入: <code>import pubsub from &#39;pubsub-js&#39;</code></p>
</li>
<li><p>接收数据：A 组件想接收数据，则在 A 组件中订阅消息，订阅的<span style="color:red">回调留在 A 组件自身。</span></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;......&#125;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">pid</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&#x27;xxx&#x27;</span>,<span class="variable language_">this</span>.<span class="property">demo</span>) <span class="comment">//订阅消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>提供数据：<code>pubsub.publish(&#39;xxx&#39;,数据)</code></p>
</li>
<li><p>最好在 beforeDestroy 钩子中，用<code>PubSub.unsubscribe(pid)</code>去<span style="color:red">取消订阅。</span></p>
</li>
</ol>
</li>
</ol>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><ol>
<li>语法：<code>this.$nextTick(回调函数)</code></li>
<li>作用：在下一次 DOM 更新结束后执行其指定的回调。</li>
<li>什么时候用：当改变数据后，要基于更新后的新 DOM 进行某些操作时，要在 nextTick 所指定的回调函数中执行。</li>
</ol>
<h2 id="Vue-封装的过度与动画"><a href="#Vue-封装的过度与动画" class="headerlink" title="Vue 封装的过度与动画"></a>Vue 封装的过度与动画</h2><ol>
<li><p>作用：在插入、更新或移除 DOM 元素时，在合适的时候给元素添加样式类名。</p>
</li>
<li><p>图示：<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105"
                      style="width:60%" 
                ></p>
</li>
<li><p>写法：</p>
<ol>
<li><p>准备好样式：</p>
<ul>
<li>元素进入的样式：<ol>
<li>v-enter：进入的起点</li>
<li>v-enter-active：进入过程中</li>
<li>v-enter-to：进入的终点</li>
</ol>
</li>
<li>元素离开的样式：<ol>
<li>v-leave：离开的起点</li>
<li>v-leave-active：离开过程中</li>
<li>v-leave-to：离开的终点</li>
</ol>
</li>
</ul>
</li>
<li><p>使用<code>&lt;transition&gt;</code>包裹要过度的元素，并配置 name 属性：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;transition name=&quot;hello&quot;&gt;</span><br><span class="line">	&lt;h1 v-show=&quot;isShow&quot;&gt;你好啊！&lt;/h1&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>备注：若有多个元素需要过度，则需要使用：<code>&lt;transition-group&gt;</code>，且每个元素都要指定<code>key</code>值。</p>
</li>
</ol>
</li>
</ol>
<h2 id="vue-脚手架配置代理"><a href="#vue-脚手架配置代理" class="headerlink" title="vue 脚手架配置代理"></a>vue 脚手架配置代理</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>​ 在 vue.config.js 中添加如下配置：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">  <span class="attr">proxy</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>说明：</p>
<ol>
<li>优点：配置简单，请求资源时直接发给前端（8080）即可。</li>
<li>缺点：不能配置多个代理，不能灵活的控制请求是否走代理。</li>
<li>工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）</li>
</ol>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>​ 编写 vue.config.js 配置具体代理规则：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">proxy</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;/api1&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">// 匹配所有以 &#x27;/api1&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>, <span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="string">&#x27;/api2&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">// 匹配所有以 &#x27;/api2&#x27;开头的请求路径</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>, <span class="comment">// 代理目标的基础路径</span></span><br><span class="line">        <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080</span></span><br><span class="line"><span class="comment">   changeOrigin默认值为true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div>

<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，且可以灵活的控制请求是否走代理。</li>
<li>缺点：配置略微繁琐，请求资源时必须加前缀。</li>
</ol>
<h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><ol>
<li><p>作用：让父组件可以向子组件指定位置插入 html 结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件</strong> 。</p>
</li>
<li><p>分类：默认插槽、具名插槽、作用域插槽</p>
</li>
<li><p>使用方式：</p>
<ol>
<li><p>默认插槽：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">           &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 定义插槽 --&gt;</span><br><span class="line">    &lt;slot&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>具名插槽：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">            &lt;template slot=&quot;center&quot;&gt;</span><br><span class="line">              &lt;div&gt;html结构1&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">            &lt;template v-slot:footer&gt;</span><br><span class="line">               &lt;div&gt;html结构2&lt;/div&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">        &lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;!-- 定义插槽 --&gt;</span><br><span class="line">    &lt;slot name=&quot;center&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;插槽默认内容...&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>作用域插槽：</p>
<ol>
<li><p>理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games 数据在 Category 组件中，但使用数据所遍历出来的结构由 App 组件决定）</p>
</li>
<li><p>具体编码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中：</span><br><span class="line">&lt;Category&gt;</span><br><span class="line">			&lt;template scope=&quot;scopeData&quot;&gt;</span><br><span class="line">				&lt;!-- 生成的是ul列表 --&gt;</span><br><span class="line">				&lt;ul&gt;</span><br><span class="line">					&lt;li v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/li&gt;</span><br><span class="line">				&lt;/ul&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line"></span><br><span class="line">&lt;Category&gt;</span><br><span class="line">			&lt;template slot-scope=&quot;scopeData&quot;&gt;</span><br><span class="line">				&lt;!-- 生成的是h4标题 --&gt;</span><br><span class="line">				&lt;h4 v-for=&quot;g in scopeData.games&quot; :key=&quot;g&quot;&gt;&#123;&#123;g&#125;&#125;&lt;/h4&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Category&gt;</span><br><span class="line">子组件中：</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;slot :games=&quot;games&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#x27;Category&#x27;,</span><br><span class="line">    props: [&#x27;title&#x27;],</span><br><span class="line">    //数据在子组件自身</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        games: [&#x27;红色警戒&#x27;, &#x27;穿越火线&#x27;, &#x27;劲舞团&#x27;, &#x27;超级玛丽&#x27;],</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
</ol>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​ 在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间通信的方式，且适用于任意组件间通信。</p>
<h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​ 多个组件需要共享数据时</p>
<h3 id="3-搭建-vuex-环境"><a href="#3-搭建-vuex-环境" class="headerlink" title="3.搭建 vuex 环境"></a>3.搭建 vuex 环境</h3><ol>
<li><p>创建文件：<code>src/store/index.js</code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//应用Vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions对象——响应组件中用户的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations对象——修改state中的数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state对象——保存具体的数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>在<code>main.js</code>中创建 vm 时传入<code>store</code>配置项</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">	<span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	<span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">	store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ol>
<li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入Vue核心库</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//引用Vuex</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="comment">//响应组件中加的动作</span></span><br><span class="line">  <span class="title function_">jia</span>(<span class="params">context, value</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&#x27;actions中的jia被调用了&#x27;,miniStore,value)</span></span><br><span class="line">    context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>, value)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="comment">//执行加</span></span><br><span class="line">  <span class="title function_">JIA</span>(<span class="params">state, value</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(&#x27;mutations中的JIA被调用了&#x27;,state,value)</span></span><br><span class="line">    state.<span class="property">sum</span> += value</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="attr">sum</span>: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  actions,</span><br><span class="line">  mutations,</span><br><span class="line">  state,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>组件中读取 vuex 中的数据：<code>$store.state.sum</code></p>
</li>
<li><p>组件中修改 vuex 中的数据：<code>$store.dispatch(&#39;action中的方法名&#39;,数据)</code> 或 <code>$store.commit(&#39;mutations中的方法名&#39;,数据)</code></p>
<blockquote>
<p>备注：若没有网络请求或其他业务逻辑，组件中也可以越过 actions，即不写<code>dispatch</code>，直接编写<code>commit</code></p>
</blockquote>
</li>
</ol>
<h3 id="5-getters-的使用"><a href="#5-getters-的使用" class="headerlink" title="5.getters 的使用"></a>5.getters 的使用</h3><ol>
<li><p>概念：当 state 中的数据需要经过加工后再使用时，可以使用 getters 加工。</p>
</li>
<li><p>在<code>store.js</code>中追加<code>getters</code>配置</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">	<span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">	......</span><br><span class="line">	getters</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>组件中读取数据：<code>$store.getters.bigSum</code></p>
</li>
</ol>
<h3 id="6-四个-map-方法的使用"><a href="#6-四个-map-方法的使用" class="headerlink" title="6.四个 map 方法的使用"></a>6.四个 map 方法的使用</h3><ol>
<li><p><strong>mapState 方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（对象写法）</span></span><br><span class="line">     ...<span class="title function_">mapState</span>(&#123;<span class="attr">sum</span>:<span class="string">&#x27;sum&#x27;</span>,<span class="attr">school</span>:<span class="string">&#x27;school&#x27;</span>,<span class="attr">subject</span>:<span class="string">&#x27;subject&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapState生成计算属性：sum、school、subject（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapState</span>([<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>mapGetters 方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（对象写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>(&#123;<span class="attr">bigSum</span>:<span class="string">&#x27;bigSum&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//借助mapGetters生成计算属性：bigSum（数组写法）</span></span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bigSum&#x27;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>mapActions 方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>(&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapActions生成：incrementOdd、incrementWait（数组形式）</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="string">&#x27;jiaWait&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>mapMutations 方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">    <span class="comment">//靠mapActions生成：increment、decrement（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br><span class="line"></span><br><span class="line">    <span class="comment">//靠mapMutations生成：JIA、JIAN（对象形式）</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;JIA&#x27;</span>,<span class="string">&#x27;JIAN&#x27;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<blockquote>
<p>备注：mapActions 与 mapMutations 使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。</p>
</blockquote>
<h3 id="7-模块化-命名空间"><a href="#7-模块化-命名空间" class="headerlink" title="7.模块化+命名空间"></a>7.模块化+命名空间</h3><ol>
<li><p>目的：让代码更好维护，让多种数据分类更加明确。</p>
</li>
<li><p>修改<code>store.js</code></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> countAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123;<span class="attr">x</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personAbout = &#123;</span><br><span class="line">  <span class="attr">namespaced</span>:<span class="literal">true</span>,<span class="comment">//开启命名空间</span></span><br><span class="line">  <span class="attr">state</span>:&#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    countAbout,</span><br><span class="line">    personAbout</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>开启命名空间后，组件中读取 state 数据：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">list</span></span><br><span class="line"><span class="comment">//方式二：借助mapState读取：</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;sum&#x27;</span>,<span class="string">&#x27;school&#x27;</span>,<span class="string">&#x27;subject&#x27;</span>]),</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>开启命名空间后，组件中读取 getters 数据：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&#x27;personAbout/firstPersonName&#x27;</span>]</span><br><span class="line"><span class="comment">//方式二：借助mapGetters读取：</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&#x27;countAbout&#x27;</span>,[<span class="string">&#x27;bigSum&#x27;</span>])</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>开启命名空间后，组件中调用 dispatch</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接dispatch</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;personAbout/addPersonWang&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapActions：</span></span><br><span class="line">...<span class="title function_">mapActions</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">incrementOdd</span>:<span class="string">&#x27;jiaOdd&#x27;</span>,<span class="attr">incrementWait</span>:<span class="string">&#x27;jiaWait&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>开启命名空间后，组件中调用 commit</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：自己直接commit</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;personAbout/ADD_PERSON&#x27;</span>,person)</span><br><span class="line"><span class="comment">//方式二：借助mapMutations：</span></span><br><span class="line">...<span class="title function_">mapMutations</span>(<span class="string">&#x27;countAbout&#x27;</span>,&#123;<span class="attr">increment</span>:<span class="string">&#x27;JIA&#x27;</span>,<span class="attr">decrement</span>:<span class="string">&#x27;JIAN&#x27;</span>&#125;),</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ol>
<li>理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。</li>
<li>前端路由：key 是路径，value 是组件。</li>
</ol>
<h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><ol>
<li><p>安装 vue-router，命令：<code>npm i vue-router</code></p>
</li>
<li><p>应用插件：<code>Vue.use(VueRouter)</code></p>
</li>
<li><p>编写 router 配置项:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入VueRouter</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入Luyou 组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建router实例对象，去管理一组一组的路由规则</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">About</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//暴露router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>实现切换（active-class 可配置高亮样式）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link active-class=&quot;active&quot; to=&quot;/about&quot;&gt;About&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>指定展示位置</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="2-几个注意点"><a href="#2-几个注意点" class="headerlink" title="2.几个注意点"></a>2.几个注意点</h3><ol>
<li>路由组件通常存放在<code>pages</code>文件夹，一般组件通常存放在<code>components</code>文件夹。</li>
<li>通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。</li>
<li>每个组件都有自己的<code>$route</code>属性，里面存储着自己的路由信息。</li>
<li>整个应用只有一个 router，可以通过组件的<code>$router</code>属性获取到。</li>
</ol>
<h3 id="3-多级路由（多级路由）"><a href="#3-多级路由（多级路由）" class="headerlink" title="3.多级路由（多级路由）"></a>3.多级路由（多级路由）</h3><ol>
<li><p>配置路由规则，使用 children 配置项：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">routes</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">About</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      <span class="comment">//通过children配置子级路由</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;news&#x27;</span>, <span class="comment">//此处一定不要写：/news</span></span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">News</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;message&#x27;</span>, <span class="comment">//此处一定不要写：/message</span></span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">Message</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>跳转（要写完整路径）：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-link to=&quot;/home/news&quot;&gt;News&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="4-路由的-query-参数"><a href="#4-路由的-query-参数" class="headerlink" title="4.路由的 query 参数"></a>4.路由的 query 参数</h3><ol>
<li><p>传递参数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带query参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail?id=666&amp;title=你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带query参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link</span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    path: &#x27;/home/message/detail&#x27;,</span><br><span class="line">    query: &#123;</span><br><span class="line">      id: 666,</span><br><span class="line">      title: &#x27;你好&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>接收参数：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">query</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">query</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="5-命名路由"><a href="#5-命名路由" class="headerlink" title="5.命名路由"></a>5.命名路由</h3><ol>
<li><p>作用：可以简化路由的跳转。</p>
</li>
<li><p>如何使用</p>
<ol>
<li><p>给路由命名：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/demo&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Demo</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Test</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">                      <span class="attr">name</span>:<span class="string">&#x27;hello&#x27;</span> <span class="comment">//给路由命名</span></span><br><span class="line">					<span class="attr">path</span>:<span class="string">&#x27;welcome&#x27;</span>,</span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Hello</span>,</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>简化跳转：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--简化前，需要写完整的路径 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/demo/test/welcome&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化后，直接通过名字跳转 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;&#123; name: &#x27;hello&#x27; &#125;&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--简化写法配合传递参数 --&gt;</span><br><span class="line">&lt;router-link</span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    name: &#x27;hello&#x27;,</span><br><span class="line">    query: &#123;</span><br><span class="line">      id: 666,</span><br><span class="line">      title: &#x27;你好&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
</ol>
<h3 id="6-路由的-params-参数"><a href="#6-路由的-params-参数" class="headerlink" title="6.路由的 params 参数"></a>6.路由的 params 参数</h3><ol>
<li><p>配置路由，声明接收 params 参数</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Home</span>,</span><br><span class="line">	<span class="attr">children</span>:[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">path</span>:<span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">News</span></span><br><span class="line">		&#125;,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">component</span>:<span class="title class_">Message</span>,</span><br><span class="line">			<span class="attr">children</span>:[</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">					<span class="attr">path</span>:<span class="string">&#x27;detail/:id/:title&#x27;</span>, <span class="comment">//使用占位符声明接收params参数</span></span><br><span class="line">					<span class="attr">component</span>:<span class="title class_">Detail</span></span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>传递参数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 跳转并携带params参数，to的字符串写法 --&gt;</span><br><span class="line">&lt;router-link :to=&quot;/home/message/detail/666/你好&quot;&gt;跳转&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 跳转并携带params参数，to的对象写法 --&gt;</span><br><span class="line">&lt;router-link</span><br><span class="line">  :to=&quot;&#123;</span><br><span class="line">    name: &#x27;xiangqing&#x27;,</span><br><span class="line">    params: &#123;</span><br><span class="line">      id: 666,</span><br><span class="line">      title: &#x27;你好&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;&quot;</span><br><span class="line">&gt;跳转&lt;/router-link&gt;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>特别注意：路由携带 params 参数时，若使用 to 的对象写法，则不能使用 path 配置项，必须使用 name 配置！</p>
</blockquote>
</li>
<li><p>接收参数：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">$route.<span class="property">params</span>.<span class="property">id</span></span><br><span class="line">$route.<span class="property">params</span>.<span class="property">title</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="7-路由的-props-配置"><a href="#7-路由的-props-配置" class="headerlink" title="7.路由的 props 配置"></a>7.路由的 props 配置</h3><p>​ 作用：让路由组件更方便的收到参数</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">	<span class="attr">path</span>:<span class="string">&#x27;detail/:id&#x27;</span>,</span><br><span class="line">	<span class="attr">component</span>:<span class="title class_">Detail</span>,</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:&#123;a:900&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件</span></span><br><span class="line">	<span class="comment">// props:true</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件</span></span><br><span class="line">	<span class="title function_">props</span>(<span class="params">route</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			<span class="attr">id</span>:route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line">			<span class="attr">title</span>:route.<span class="property">query</span>.<span class="property">title</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="8-lt-router-link-gt-的-replace-属性"><a href="#8-lt-router-link-gt-的-replace-属性" class="headerlink" title="8.&lt;router-link&gt;的 replace 属性"></a>8.<code>&lt;router-link&gt;</code>的 replace 属性</h3><ol>
<li>作用：控制路由跳转时操作浏览器历史记录的模式</li>
<li>浏览器的历史记录有两种写入方式：分别为<code>push</code>和<code>replace</code>，<code>push</code>是追加历史记录，<code>replace</code>是替换当前记录。路由跳转时候默认为<code>push</code></li>
<li>如何开启<code>replace</code>模式：<code>&lt;router-link replace .......&gt;News&lt;/router-link&gt;</code></li>
</ol>
<h3 id="9-编程式路由导航"><a href="#9-编程式路由导航" class="headerlink" title="9.编程式路由导航"></a>9.编程式路由导航</h3><ol>
<li><p>作用：不借助<code>&lt;router-link&gt; </code>实现路由跳转，让路由跳转更加灵活</p>
</li>
<li><p>具体编码：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//$router的两个API</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: xxx,</span><br><span class="line">    <span class="attr">title</span>: xxx,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">replace</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: xxx,</span><br><span class="line">    <span class="attr">title</span>: xxx,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">forward</span>() <span class="comment">//前进</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">back</span>() <span class="comment">//后退</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">go</span>() <span class="comment">//可前进也可后退</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="10-缓存路由组件"><a href="#10-缓存路由组件" class="headerlink" title="10.缓存路由组件"></a>10.缓存路由组件</h3><ol>
<li><p>作用：让不展示的路由组件保持挂载，不被销毁。</p>
</li>
<li><p>具体编码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;keep-alive include=&quot;News&quot;&gt; </span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="11-两个新的生命周期钩子"><a href="#11-两个新的生命周期钩子" class="headerlink" title="11.两个新的生命周期钩子"></a>11.两个新的生命周期钩子</h3><ol>
<li>作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。</li>
<li>具体名字：<ol>
<li><code>activated</code>路由组件被激活时触发。</li>
<li><code>deactivated</code>路由组件失活时触发。</li>
</ol>
</li>
</ol>
<h3 id="12-路由守卫"><a href="#12-路由守卫" class="headerlink" title="12.路由守卫"></a>12.路由守卫</h3><ol>
<li><p>作用：对路由进行权限控制</p>
</li>
<li><p>分类：全局守卫、独享守卫、组件内守卫</p>
</li>
<li><p>全局守卫:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局前置守卫：初始化时执行、每次路由切换前执行</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEach&#x27;</span>, to, <span class="keyword">from</span>)</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">isAuth</span>) &#123;</span><br><span class="line">    <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">//权限控制的具体规则</span></span><br><span class="line">      <span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">      <span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>() <span class="comment">//放行</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局后置守卫：初始化时执行、每次路由切换后执行</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;afterEach&#x27;</span>, to, <span class="keyword">from</span>)</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">title</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> <span class="comment">//修改网页的title</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = <span class="string">&#x27;vue_test&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>独享守卫:</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">beforeEnter</span>(<span class="params">to,<span class="keyword">from</span>,next</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;beforeEnter&#x27;</span>,to,<span class="keyword">from</span>)</span><br><span class="line">	<span class="keyword">if</span>(to.<span class="property">meta</span>.<span class="property">isAuth</span>)&#123; <span class="comment">//判断当前路由是否需要进行权限控制</span></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;atguigu&#x27;</span>)&#123;</span><br><span class="line">			<span class="title function_">next</span>()</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="title function_">alert</span>(<span class="string">&#x27;暂无权限查看&#x27;</span>)</span><br><span class="line">			<span class="comment">// next(&#123;name:&#x27;guanyu&#x27;&#125;)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="title function_">next</span>()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>组件内守卫：</p>
<div class="highlight-container" data-rel="Js"><figure class="iseeu highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//进入守卫：通过路由规则，进入该组件时被调用</span></span><br><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//离开守卫：通过路由规则，离开该组件时被调用</span></span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="13-路由器的两种工作模式"><a href="#13-路由器的两种工作模式" class="headerlink" title="13.路由器的两种工作模式"></a>13.路由器的两种工作模式</h3><ol>
<li>对于一个 url 来说，什么是 hash 值？—— #及其后面的内容就是 hash 值。</li>
<li>hash 值不会包含在 HTTP 请求中，即：hash 值不会带给服务器。</li>
<li>hash 模式：<ol>
<li>地址中永远带着#号，不美观 。</li>
<li>若以后将地址通过第三方手机 app 分享，若 app 校验严格，则地址会被标记为不合法。</li>
<li>兼容性较好。</li>
</ol>
</li>
<li>history 模式：<ol>
<li>地址干净，美观 。</li>
<li>兼容性和 hash 模式相比略差。</li>
<li>应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题。</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtual Dom &amp; Diff</title>
    <url>/2023/08/29/Virtual%20DOM%20%E5%92%8C%20Diff%20%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p>Vue 的响应式系统是其核心特点之一，它使得数据的变化能够自动地更新视图。响应式系统的原理主要涉及以下几个方面：</p>
<ol>
<li><p><strong>侦听属性（Getter 和 Setter）：</strong> Vue 在初始化数据对象时，会使用 JavaScript 的 <code>Object.defineProperty</code> 或 <code>Proxy</code> 来劫持对象属性的访问（Getter）和修改（Setter）。这意味着当你访问一个属性时，Vue 能够捕捉到这个操作，并执行相应的逻辑。</p>
</li>
<li><p><strong>依赖追踪：</strong> 当组件渲染时，它会读取数据属性，这时 Vue 会将这些属性与当前组件实例建立关联。在关联建立后，属性变化时就会触发相应的更新操作。这个关联关系被称为“依赖”，Vue 使用一种叫做“依赖追踪”的机制来收集依赖关系。</p>
</li>
<li><p><strong>Watcher（观察者）：</strong> 在模板中，如果一个属性被用于渲染，那么 Vue 会创建一个 Watcher 对象来追踪这个属性的依赖关系。每个 Watcher 对象都和一个表达式相关联，这个表达式是属性在模板中的引用。当属性变化时，依赖于这个属性的所有 Watcher 都会被通知，从而触发更新。</p>
</li>
<li><p><strong>响应式数据的生成：</strong> 在 Vue 实例化过程中，会将数据对象中的每个属性转化为“响应式”的。当你修改这些属性时，Vue 会通知相关的 Watcher，从而触发视图的更新。</p>
</li>
<li><p><strong>批量异步更新：</strong> 为了提高性能，Vue 在一次数据变更中会进行异步的批量更新。它将数据变更的操作放入一个异步队列中，在下一个事件循环周期中，才会批量处理这些更新操作。这样可以减少不必要的 DOM 操作，提高性能。</p>
</li>
</ol>
<p>综上所述，Vue 的响应式系统的核心思想是通过拦截属性的访问和修改操作，来建立属性与依赖之间的关联。当属性发生变化时，所有依赖于这个属性的 Watcher 都会被通知，从而自动触发视图的更新，实现了数据与视图的自动同步。这种机制使得开发者能够更便捷地管理和维护数据状态，并且提供了更好的用户体验。</p>
<h2 id="Virtual-DOM-和-Diff-算法"><a href="#Virtual-DOM-和-Diff-算法" class="headerlink" title="Virtual DOM 和 Diff 算法"></a>Virtual DOM 和 Diff 算法</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>对于<code>JS</code> 代码或者<code>CSS</code>样式代码，每次对 DOM 直接进行操作，会触发回流（<code>reflow</code>）和重绘（<code>repaint</code>），造成巨大开销，所以减少 DOM 操作是网页优化的策略之一，由此出现了虚拟 DOM 和 Diff 算法；顾名思义，虚拟 DOM 并非是一个真实存在的 DOM，也就是还并未上树，Diff 算法也就是比较新旧虚拟 DOM 两者（<code>oldVnode</code>，<code>newVnode</code>）的不同之处，在逻辑里对比得出最小量更新再进行上树，也就减少了 DOM 操作。</p>
<blockquote>
<p><code>reflow</code> 与 <code>repaint</code>：浏览器使用的是流式布局（Flow Based Layout），会把 HTML 解析成 <code>DOM</code> 树，把 CSS 解析成 <code>CSSOM</code> 树，<code>DOM</code> 和 <code>CSSOM</code> 合并成为 <code>Render Tree</code>，然后就可以进行后续渲染… 由于浏览器的流式布局。</p>
<p>当浏览器渲染完成后，<code>Render Tree</code>中部分或者全部尺寸、结构、或某些属性发生变化的时候，浏览器重新渲染的过程成为回流（<code>reflow</code>），以下操作都会导致回流：</p>
<ul>
<li><p>页面首次渲染</p>
</li>
<li><p>浏览器窗口大小发生改变</p>
</li>
<li><p>元素尺寸或位置发生改变</p>
</li>
<li><p>元素内容变化（文字数量或图片大小等等）</p>
</li>
<li><p>元素字体大小变化</p>
</li>
<li><p>添加或者删除<strong>可见</strong>的<code>DOM</code>元素</p>
</li>
<li><p>激活<code>CSS</code>伪类（例如：<code>:hover</code>）</p>
</li>
<li><p>查询某些属性或调用某些方法</p>
</li>
</ul>
<p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘</p>
<p>​ 显然，回流的代价比重绘要高，现代浏览器会对频繁的回流或重绘操作进行优化：</p>
<p>​ 浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达 到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p>
<p><strong>回流必将引起重绘，重绘不一定会引起回流。</strong></p>
</blockquote>
<h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p>虚拟 DOM（Virtual DOM）是 Vue、React 等前端框架中的核心概念，它是一种用 JavaScript 对象表示真实 DOM 结构的方式。虚拟 DOM 的原理是通过对比前后两个虚拟 DOM 树的差异，最小化对实际 DOM 的操作，从而提高性能。</p>
<p>虚拟 DOM 的原理主要包括以下步骤：</p>
<ol>
<li><p><strong>初始渲染：</strong> 当组件首次渲染时，会生成一个虚拟 DOM 树，这个树与实际 DOM 结构类似，但只是在内存中的一个 JavaScript 对象表示。</p>
</li>
<li><p><strong>更新数据：</strong> 当数据发生变化，需要更新组件时，会生成一个新的虚拟 DOM 树。</p>
</li>
<li><p><strong>Diff 算法：</strong> 新旧虚拟 DOM 树会进行 Diff（差异）计算。Diff 算法的目标是找出新旧虚拟 DOM 之间的差异，即找出哪些节点需要更新、添加或删除。</p>
</li>
<li><p><strong>批量更新：</strong> 根据 Diff 计算的结果，将需要更新的部分抽象成一系列操作，然后一次性更新到实际 DOM 中。这样可以减少实际 DOM 操作的次数，提高性能。</p>
</li>
<li><p><strong>应用更新：</strong> 将更新后的虚拟 DOM 树渲染到实际 DOM 上，用户最终看到的就是更新后的界面。</p>
</li>
</ol>
<p>虚拟 DOM 的核心优势在于它将实际 DOM 操作的成本降低到最低。在每次数据变化时，框架会生成一个新的虚拟 DOM 树，然后与之前的虚拟 DOM 树进行比较，找出需要更新的部分。这个比较过程能够在 JavaScript 层面快速完成，避免了直接操作实际 DOM 所带来的性能损耗。最终，只有真正需要更新的部分会触发实际 DOM 操作，从而提高了性能效率。</p>
<p>总之，虚拟 DOM 的原理是通过在 JavaScript 中维护一个轻量级的 DOM 抽象，通过比较差异来最小化实际 DOM 操作，从而在性能和用户体验方面带来优势。</p>
<h3 id="Diff-算法"><a href="#Diff-算法" class="headerlink" title="Diff 算法"></a>Diff 算法</h3><p>Diff 算法是虚拟 DOM 技术的关键部分，用于比较新旧虚拟 DOM 树的差异并最小化对实际 DOM 的操作。下面是 Diff 算法的一般流程：</p>
<ol>
<li><p><strong>比较根节点：</strong> 首先，比较新旧虚拟 DOM 树的根节点。如果它们的类型不同，直接将旧节点替换为新节点，从而触发整个子树的重新渲染。</p>
</li>
<li><p><strong>深度优先遍历：</strong> 如果根节点类型相同，Diff 算法会进行深度优先遍历。它会逐层比较新旧节点的子节点，找出它们之间的差异。</p>
</li>
<li><p><strong>同级节点比较：</strong> 在遍历过程中，Diff 算法会按照同级节点的顺序进行比较。对于同级节点，通常情况下会比较它们的标签名（节点类型）、Key（如果存在）、属性和事件等。</p>
</li>
<li><p><strong>更新操作：</strong> 如果同级节点存在差异，Diff 算法会执行相应的更新操作。这些操作可以是插入新节点、移除旧节点、替换节点、更新属性、更新文本内容等。</p>
</li>
<li><p><strong>Key 的作用：</strong> 如果节点存在 Key 属性，Diff 算法会通过 Key 来判断节点是否可复用。如果新旧节点的 Key 相同，表示它们是同一节点，可以复用，否则需要进行替换操作。</p>
</li>
<li><p><strong>递归处理子节点：</strong> 对于有子节点的节点，Diff 算法会递归地对子节点进行比较和更新。这样能够保证整个 DOM 树的比较过程。</p>
</li>
<li><p><strong>批量更新：</strong> 在比较完所有节点后，Diff 算法会将需要更新的操作收集起来，并一次性应用到实际 DOM 上，从而减少实际 DOM 操作的次数。</p>
</li>
</ol>
<p>需要注意的是，Diff 算法在进行节点比较时，会尽可能地在同级节点中找到相同的节点，从而复用之前的实际 DOM 结构。这样能够避免频繁地添加、移除节点，从而提高性能。</p>
<p>虽然这是一个简化的 Diff 算法流程，实际框架会根据不同的情况进行优化，以提高算法效率。但总体来说，Diff 算法的目标是找出新旧虚拟 DOM 树之间的差异，将这些差异抽象为一系列操作，并最小化对实际 DOM 的操作，从而提高性能。</p>
<h2 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a>模板编译</h2><p>模板编译是将 Vue 中的模板语法（如指令、插值等）转换为渲染函数的过程。渲染函数可以生成虚拟 DOM，从而实现视图的渲染。以下是模板编译的一般原理：</p>
<ol>
<li><p><strong>解析：</strong> 模板编译开始时，会先对模板字符串进行解析。解析器会将模板字符串分析成一个个 Token，每个 Token 包含了类型、标签名、属性等信息。这个解析过程将模板字符串转化为一个 Token 流。</p>
</li>
<li><p><strong>优化：</strong> 在得到 Token 流后，编译器会对 Token 进行优化。其中一个重要的优化是静态节点的检测。静态节点是在编译时就能确定不会变化的节点，编译器会将它们标记出来，这样在后续的渲染过程中可以跳过对这些节点的比较和更新，提高性能。</p>
</li>
<li><p><strong>生成渲染函数：</strong> 优化后的 Token 流会被传递给代码生成器，它会根据 Token 生成对应的渲染函数。渲染函数是一个 JavaScript 函数，它接受数据作为参数，生成虚拟 DOM。生成的渲染函数会嵌套在一个闭包内部，保持对编译器生成的一些辅助函数的引用。</p>
</li>
<li><p><strong>渲染函数执行：</strong> 当数据发生变化时，调用渲染函数，传入新的数据。渲染函数会根据数据生成新的虚拟 DOM，然后通过 Diff 算法比较新旧虚拟 DOM，找出需要更新的部分。</p>
</li>
<li><p><strong>批量更新：</strong> 根据 Diff 算法的结果，将需要更新的操作批量执行。这样能够最小化对实际 DOM 的操作，提高性能。</p>
</li>
</ol>
<p>需要注意的是，模板编译是在构建阶段进行的，它将模板转化为渲染函数，因此只需要执行一次。这个过程能够将模板中的语法转化为 JavaScript 代码，使得在运行时能够快速地生成虚拟 DOM 并进行视图的更新。</p>
<p>总结起来，模板编译的原理是通过解析模板字符串、优化生成渲染函数，将模板中的语法转化为 JavaScript 代码，以实现快速生成虚拟 DOM 并进行视图渲染。这个过程在 Vue 框架中发挥着关键作用。</p>
<h2 id="组件化架构"><a href="#组件化架构" class="headerlink" title="组件化架构"></a>组件化架构</h2><p>Vue 的组件化架构是其核心特点之一，它基于组件的概念构建用户界面。以下是 Vue 组件化架构的一般原理：</p>
<ol>
<li><p><strong>组件定义：</strong> 在 Vue 中，一个组件可以通过创建一个 Vue 实例来定义。你可以使用 Vue.extend() 或直接使用 Vue 构造函数来定义一个组件。组件可以包含数据、模板、样式、方法等。</p>
</li>
<li><p><strong>模板：</strong> 组件通常包含一个模板部分，用于描述组件的外观。模板可以使用 Vue 的模板语法，包括插值、指令、条件渲染、列表渲染等。模板中的数据绑定会自动响应数据的变化。</p>
</li>
<li><p><strong>数据：</strong> 每个组件都可以拥有自己的数据，这些数据可以在组件内部使用。你可以使用 Vue 的响应式数据绑定，通过定义数据属性来实现自动更新视图。</p>
</li>
<li><p><strong>属性和事件：</strong> 组件可以接收父组件传递的属性（props），这些属性可以用于定制组件的外观和行为。组件还可以通过 <code>$emit</code> 方法触发自定义事件，与父组件或其他组件进行通信。</p>
</li>
<li><p><strong>组件嵌套：</strong> 在 Vue 中，你可以将一个组件嵌套在另一个组件内部。这种嵌套可以形成组件树的结构，从而构建复杂的界面。父组件可以传递数据和属性给子组件，实现数据的传递和共享。</p>
</li>
<li><p><strong>生命周期：</strong> Vue 组件有一系列生命周期钩子函数，用于在组件不同阶段执行逻辑。例如，<code>created</code> 钩子在组件被创建后调用，<code>mounted</code> 钩子在组件被添加到 DOM 后调用。</p>
</li>
<li><p><strong>全局和局部组件：</strong> 你可以在全局范围内注册一个组件，使其在任何地方都可用。也可以在局部范围内注册一个组件，使其只在特定的组件中可用。这样能够更好地管理组件的作用域和可见性。</p>
</li>
<li><p><strong>动态组件：</strong> Vue 允许你使用 <code>&lt;component&gt;</code> 元素动态地渲染不同的组件。通过绑定一个动态的组件名，你可以根据数据的变化来切换显示不同的组件。</p>
</li>
<li><p><strong>异步组件：</strong> Vue 支持异步加载组件，通过使用 <code>import()</code> 或返回 Promise 的工厂函数来定义异步组件。这可以优化应用的性能，只在需要时才加载组件。</p>
</li>
<li><p><strong>插槽：</strong> 插槽（Slot）是 Vue 中用于分发内容的一种机制。通过插槽，你可以将内容插入到组件的特定位置，使得组件更具灵活性。</p>
</li>
</ol>
<p>综上所述，Vue 的组件化架构通过定义组件、模板、数据、属性、事件等实现了界面的模块化和可组合性。通过组件的嵌套和复用，能够构建出复杂的用户界面。Vue 的生命周期和响应式数据绑定等机制使得组件可以具有自身的行为和状态，从而实现了更高的可维护性和可重用性。</p>
<h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>Vue 的生命周期钩子是一组在组件生命周期不同阶段被调用的函数。这些钩子函数允许你在组件的不同生命周期阶段执行自定义的逻辑。Vue 的生命周期钩子原理涉及以下几个方面：</p>
<ol>
<li><p><strong>初始化阶段：</strong></p>
<ul>
<li><code>beforeCreate</code>: 在组件实例被创建之前被调用。此时，组件的数据和方法还未初始化。</li>
<li><code>created</code>: 在组件实例创建完成后被调用。此时，组件的数据已初始化，但 DOM 还未生成。</li>
</ul>
</li>
<li><p><strong>模板编译和挂载阶段：</strong></p>
<ul>
<li><code>beforeMount</code>: 在组件模板被编译并挂载到实际 DOM 之前被调用。此时，组件模板已编译完成，但还未渲染到页面上。</li>
<li><code>mounted</code>: 在组件模板被编译并挂载到实际 DOM 之后被调用。此时，组件已经渲染到页面上，并且可以访问到 DOM 元素。</li>
</ul>
</li>
<li><p><strong>更新阶段：</strong></p>
<ul>
<li><code>beforeUpdate</code>: 在数据更新导致重新渲染之前被调用。此时，组件数据已更新，但 DOM 还未重新渲染。</li>
<li><code>updated</code>: 在数据更新导致重新渲染之后被调用。此时，组件数据已更新，DOM 也已重新渲染。</li>
</ul>
</li>
<li><p><strong>销毁阶段：</strong></p>
<ul>
<li><code>beforeDestroy</code>: 在组件实例销毁之前被调用。此时，组件还处于活动状态，可以执行清理工作。</li>
<li><code>destroyed</code>: 在组件实例销毁之后被调用。此时，组件已经被完全销毁，不再能访问到组件的数据和方法。</li>
</ul>
</li>
</ol>
<p>生命周期钩子的原理是在 Vue 实例化时，将钩子函数注册到组件的生命周期中。当组件在不同阶段进行相应的操作时，Vue 会自动调用相应的钩子函数。例如，在创建组件实例时，会调用 <code>beforeCreate</code> 和 <code>created</code> 钩子；在更新组件数据时，会调用 <code>beforeUpdate</code> 和 <code>updated</code> 钩子，依此类推。</p>
<p>需要注意的是，Vue 3 在生命周期钩子方面有一些变化，引入了 <code>beforeMount</code> 和 <code>mounted</code> 钩子的代替品：<code>beforeMount</code> 变为 <code>onBeforeMount</code>，<code>mounted</code> 变为 <code>onMounted</code>，以此类推。这些变化是为了更好地与 Vue 3 的 Composition API 结合使用。</p>
<p>总之，Vue 的生命周期钩子原理是在组件生命周期的不同阶段，自动调用注册的钩子函数，使得开发者能够在不同的时刻执行自定义逻辑，实现更灵活的组件行为。</p>
<h2 id="指令和事件"><a href="#指令和事件" class="headerlink" title="指令和事件"></a>指令和事件</h2><p>Vue 提供了一系列指令（如 <code>v-model</code>、<code>v-bind</code>、<code>v-if</code> 等）和事件（如 <code>@click</code>、<code>@input</code> 等）来操作 DOM 和实现交互。这些指令和事件能够方便地绑定数据、响应用户输入以及更新视图。</p>
<p><strong>指令原理：</strong></p>
<ol>
<li><p><strong>解析和编译阶段：</strong> 在 Vue 的编译阶段，会解析模板中的指令，例如 <code>v-bind</code>、<code>v-model</code> 等。解析后的指令会被转化成对应的虚拟 DOM 渲染函数。</p>
</li>
<li><p><strong>运行时渲染阶段：</strong> 在组件渲染时，虚拟 DOM 渲染函数会执行指令的逻辑。例如，<code>v-bind</code> 指令会根据数据动态绑定元素属性，<code>v-model</code> 指令会双向绑定输入框的值。</p>
</li>
<li><p><strong>响应式绑定：</strong> 指令通常涉及到数据的绑定和更新。Vue 会根据数据的变化，自动更新指令绑定的内容。例如，<code>v-bind</code> 指令会监听数据变化，实时更新绑定的属性值。</p>
</li>
</ol>
<p><strong>事件原理：</strong></p>
<ol>
<li><p><strong>事件绑定：</strong> 在模板中，可以使用 <code>@</code> 或 <code>v-on</code> 指令来绑定事件监听器。例如，<code>@click</code> 或 <code>v-on:click</code> 绑定点击事件。</p>
</li>
<li><p><strong>事件代理：</strong> Vue 通过事件代理的方式，将事件监听器绑定到组件的根元素上。这样就可以在组件内部的子元素上触发事件，事件会冒泡到根元素上。</p>
</li>
<li><p><strong>事件处理：</strong> 当触发事件时，Vue 会调用事件监听器。事件监听器是 Vue 组件中的方法，它可以访问组件的数据和方法。你可以在事件监听器中执行逻辑，更新数据或与服务器进行交互。</p>
</li>
<li><p><strong>事件参数：</strong> 事件监听器可以接收事件参数，例如 <code>$event</code>。你可以将事件参数传递给监听器方法，以便在方法内部使用。</p>
</li>
<li><p><strong>事件修饰符：</strong> Vue 提供事件修饰符，用于控制事件的行为。例如，<code>.prevent</code> 修饰符可以阻止默认行为，<code>.stop</code> 修饰符可以停止事件冒泡。</p>
</li>
</ol>
<p>需要注意的是，Vue 的指令和事件是通过 JavaScript 代码实现的，它们会在编译和运行时被转化成相应的逻辑。指令通过虚拟 DOM 渲染函数实现数据绑定和更新，事件通过事件代理和监听器实现用户交互和逻辑处理。</p>
<p>总之，Vue 的指令和事件机制使得开发者可以方便地操作 DOM 元素和处理用户交互。这些机制基于 Vue 的编译和运行时系统，以及响应式数据绑定，使得前端开发更加便捷和灵活。</p>
<h2 id="异步更新队列"><a href="#异步更新队列" class="headerlink" title="异步更新队列"></a>异步更新队列</h2><p>Vue 在进行数据更新时，通常将更新操作放入异步队列中，然后在一个事件循环中进行更新。这样可以保证更新的顺序性，同时也能够合并多次数据变更，提升性能。</p>
<p>Vue 异步更新队列是 Vue 在更新视图时的一种优化机制，它将多个数据变更操作合并到一次更新中，从而提高性能。这个机制涉及到 Vue 的异步更新策略、事件循环和 nextTick 原理。以下是 Vue 异步更新队列的原理：</p>
<ol>
<li><p><strong>响应式数据变更：</strong> 当 Vue 组件的响应式数据发生变化时，Vue 会标记这些变化，并将这些变化放入一个队列中。</p>
</li>
<li><p><strong>异步更新策略：</strong> Vue 使用异步更新策略，将数据变更操作延迟到下一个事件循环中执行。这样做的目的是为了将多次数据变更操作合并为一次，从而减少不必要的 DOM 操作和提高性能。</p>
</li>
<li><p><strong>事件循环：</strong> JavaScript 运行在事件循环中，每一轮事件循环被称为一个 tick。在每个 tick 内，JavaScript 会执行一些任务，然后检查是否需要更新视图。Vue 利用事件循环来实现异步更新队列。</p>
</li>
<li><p><strong>nextTick 原理：</strong> <code>nextTick</code> 是 Vue 提供的一个 API，它能够在 DOM 更新之后执行回调函数。在 Vue 内部，<code>nextTick</code> 利用了 JavaScript 的事件循环机制，将回调函数推入微任务队列（microtask queue）中，在 DOM 更新之后立即执行。</p>
</li>
<li><p><strong>更新队列处理：</strong> 在每个事件循环中，Vue 会检查更新队列，将队列中的变更操作合并并执行。这样，多个数据变更会在同一个事件循环内更新视图，从而提高性能。</p>
</li>
<li><p><strong>同步更新情况：</strong> 在某些情况下，如果你希望立即执行数据变更操作并更新视图，可以使用 <code>$nextTick</code> 或者在异步操作内部调用 <code>this.$forceUpdate()</code>。</p>
</li>
</ol>
<p>通过异步更新队列，Vue 能够将多个数据变更操作合并为一次，减少不必要的性能开销。这种机制保证了响应式数据的更新和视图的同步性，同时也使得开发者能够更好地控制数据的更新时机。</p>
<h2 id="响应式-API"><a href="#响应式-API" class="headerlink" title="响应式 API"></a>响应式 API</h2><p>Vue 的响应式 API 是其核心功能之一，它通过数据劫持和依赖追踪实现了数据的自动更新。以下是 Vue 响应式 API 的原理：</p>
<ol>
<li><p><strong>数据劫持：</strong> 在 Vue 中，每当创建一个数据对象时，Vue 会将数据对象的属性转换成 getter 和 setter。这样，当访问和修改属性时，Vue 可以捕获这些操作，并进行相应的处理。</p>
</li>
<li><p><strong>依赖追踪：</strong> 在数据劫持过程中，Vue 会为每个属性创建一个依赖追踪系统。每个属性都会有一个依赖集合，用于存储依赖于该属性的观察者（Watcher）。</p>
</li>
<li><p><strong>观察者模式：</strong> 观察者模式是 Vue 响应式系统的关键。当属性被访问时，Vue 会收集订阅了该属性的观察者，这些观察者会被添加到属性的依赖集合中。</p>
</li>
<li><p><strong>编译阶段：</strong> 在模板编译阶段，Vue 会解析模板中的表达式，识别出其中的数据引用。这些数据引用将被转化为 getter 调用，从而将观察者与属性建立联系。</p>
</li>
<li><p><strong>依赖收集：</strong> 在组件实例化时，Vue 会创建一个 Watcher 实例。这个 Watcher 实例会在模板中的每个数据引用处执行 getter，从而触发属性的依赖收集过程。</p>
</li>
<li><p><strong>派发更新：</strong> 当属性的值发生变化时，其 setter 会被调用。在 setter 中，Vue 会通知属性的所有观察者进行更新，从而保证视图与数据的同步性。</p>
</li>
<li><p><strong>异步更新：</strong> 为了提高性能，Vue 使用异步更新队列将多个数据变更操作合并到一次更新中。这样可以减少不必要的 DOM 操作，提高渲染性能。</p>
</li>
<li><p><strong>虚拟 DOM：</strong> 当数据更新时，Vue 会生成一个虚拟 DOM 树。虚拟 DOM 与之前的虚拟 DOM 进行比较，找出需要更新的部分，然后进行最小化的 DOM 操作。</p>
</li>
</ol>
<p>通过数据劫持、依赖追踪和观察者模式，Vue 实现了数据的自动更新。这种机制使得开发者无需手动操作 DOM，而是通过操作数据，自动触发视图的更新。这种响应式的特性使得 Vue 构建动态、高效的用户界面成为可能。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Java考证题目</title>
    <url>/2023/08/29/%E5%8D%8E%E8%BF%AA%E8%80%83%E8%AF%81/</url>
    <content><![CDATA[<h3 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h3><p><strong>题目 1</strong><br>Linux 系统中对名为 fido 的文件用 chmod 551 fido 进行了修改， 则它的许可权是？</p>
<ul>
<li>选项 1: -rwxr-xr-x</li>
<li>选项 2: -rwxr–r</li>
<li>选项 3: -r–r–r</li>
<li>选项 4: -r-xr-x—x</li>
</ul>
<p>答案: D</p>
<p><strong>题目 2</strong><br>不紧急也不重要的工作采用（ ）方式解决。</p>
<ul>
<li>选项 1: 妥协</li>
<li>选项 2: 迁就</li>
<li>选项 3: 回避</li>
<li>选项 4: 合作</li>
</ul>
<p>答案: C</p>
<p><strong>题目 3</strong><br>下列关于 ORACLE 数据库的描述,不正确的是？</p>
<ul>
<li>选项 1: 索引表含 ROWID 值</li>
<li>选项 2: “一个事务即使不被提交, 也会被写入到重做日志中”</li>
<li>选项 3: 拥有不同大小的回滚段没有任何益处</li>
<li>选项 4: COMMIT 后,数据不一定立即写入数据文件中</li>
</ul>
<p>答案: A</p>
<p><strong>题目 4</strong><br>下列不是 Linux 系统进程类型的是</p>
<ul>
<li>选项 1: 交互进程</li>
<li>选项 2: 批处理进程</li>
<li>选项 3: 守护进程</li>
<li>选项 4: 就绪进程</li>
</ul>
<p>答案: D</p>
<p><strong>题目 5</strong><br>能有效地监督组织各项计划的落实和执行情况，发现计划与实际之间的差距，这一管理环节是</p>
<ul>
<li>选项 1: 计划</li>
<li>选项 2: 组织</li>
<li>选项 3: 领导</li>
<li>选项 4: 控制</li>
</ul>
<p>答案: D</p>
<p><strong>题目 6</strong><br>划分软件生存周期的阶段时所应遵循的基本原则是</p>
<ul>
<li>选项 1: 各阶段的任务尽可能相关性</li>
<li>选项 2: 各阶段的任务尽可能相对独立</li>
<li>选项 3: 各阶段的任务在时间上连续</li>
<li>选项 4: 各阶段的任务在时间上相对独立</li>
</ul>
<p>答案: B</p>
<p><strong>题目 7</strong><br>古人云：“运筹于帷幄之中，决胜于千里之外”， 这里的“运筹帷幄”反映了管理的哪一个职能？</p>
<ul>
<li>选项 1: 计划职能</li>
<li>选项 2: 组织职能</li>
<li>选项 3: 领导职能</li>
<li>选项 4: 控制职能</li>
</ul>
<p>答案: A</p>
<p><strong>题目 8</strong><br>一个软件项目是否进行开发的结论是在哪个文档中作出的</p>
<ul>
<li>选项 1: 软件开发计划</li>
<li>选项 2: 可行性报告</li>
<li>选项 3: 需求分析说明书</li>
<li>选项 4: 测试报告</li>
</ul>
<p>答案: B</p>
<p><strong>题目 9</strong><br>预先决定要做什么、为什么要做、何时去做、在何地做、由什么人做以及如何做，是管理哪一项职能的任务？</p>
<ul>
<li>选项 1: 控制</li>
<li>选项 2: 组织</li>
<li>选项 3: 领导</li>
<li>选项 4: 计划</li>
</ul>
<p>答案: D</p>
<p><strong>题目 10</strong><br>软件的横向重用是指重用不同应用领域中的软件元素。 （ ）是一种典型的、原始的横向重用机制。</p>
<ul>
<li>选项 1: 对象</li>
<li>选项 2: 构件</li>
<li>选项 3: 标准函数库</li>
<li>选项 4: 设计模式</li>
</ul>
<p>答案: C</p>
<p><strong>题目 11</strong><br>某服务器软件系统能够正确运行并得出计算结果，但存在“系统出错后不能在要求的时间内恢复到正常状态”和“对系统进行二次开发时总要超过半年的时间”两个问题，上述问题依次与质量属性中的( )相关</p>
<ul>
<li>选项 1: 可用性和性能</li>
<li>选项 2: 性能和可修改性</li>
<li>选项 3: 性能和可测试性</li>
<li>选项 4: 可用性和可修改性</li>
</ul>
<p>答案: D</p>
<p><strong>题目 12</strong><br>在哪一层上监听客户所作的远程方法调用，并重定向服务器上的远程 RMI 服务的调用？</p>
<ul>
<li>选项 1: Remote Reference 层</li>
<li>选项 2: Application 层</li>
<li>选项 3: Stub&#x2F;Skeleton 层</li>
<li>选项 4: Transport 层</li>
</ul>
<p>答案: C</p>
<p><strong>题目 13</strong><br>某软件企业开发了一套能够同硬件结合以提高设备性能的软件产品，向国家专利局申请方法发明专利，获得了专利权，并为该软件产品冠以“昆仑”商品专用标识，但未进行商标注册上市销售。 此情况下，该软件产品不可能得到我国（ ）的保护</p>
<ul>
<li>选项 1: 著作权法</li>
<li>选项 2: 专利法</li>
<li>选项 3: 商标法</li>
<li>选项 4: 刑法</li>
</ul>
<p>答案: C</p>
<p><strong>题目 14</strong><br>在三层结构中，数据访问层承担的责任是？</p>
<ul>
<li>选项 1: 定义实体类</li>
<li>选项 2: 数据的增删改查操作</li>
<li>选项 3: 业务逻辑的描述</li>
<li>选项 4:</li>
</ul>
<p>页面展示和控制转发</p>
<p>答案: B</p>
<p><strong>题目 15</strong><br>某公司欲开发一个软件系统的在线文档帮助系统，用户可以在任何一个查询上下文中输入查询关键字，如果当前查询环境下没有相关内容，则系统会将查询按照一定的顺序转发给其他查询环境。 基于上述需求，采用( )最为合适</p>
<ul>
<li>选项 1: 责任链模式</li>
<li>选项 2: 桥接模式</li>
<li>选项 3: 装饰模式</li>
<li>选项 4: 适配器模式</li>
</ul>
<p>答案: C</p>
<p><strong>题目 16</strong><br>使用 HTTPSession 接口来跟踪你的 Servlets 中会话数据。 为把值加入到此会话对象，你应使用哪个函数？</p>
<ul>
<li>选项 1: setValue()</li>
<li>选项 2: addValue()</li>
<li>选项 3: putValue()</li>
<li>选项 4: addSession()</li>
</ul>
<p>答案: C</p>
<p><strong>题目 17</strong><br>下面的程序执行后没有报错，但数据总保存不到数据库，最可能的原因是</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">imain</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"> SessionFactory sf=<span class="keyword">new</span> <span class="title class_">Configration</span>().configure().buildSessionFactory();</span><br><span class="line"> Session session=sf.openSession();</span><br><span class="line"> Medal medal=<span class="keyword">new</span> <span class="title class_">Medal</span>();</span><br><span class="line"> medal.setOwner(“totong”);</span><br><span class="line"> medal.setType(“Gold medal”);</span><br><span class="line"> session.save(user);</span><br><span class="line"> session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>选项 1: 配置文件配置有误</li>
<li>选项 2: 没有在配置文件中包含对映射文件的声明</li>
<li>选项 3: 没有对持久化操作捕捉异常</li>
<li>选项 4: 没有开启事务</li>
</ul>
<p>答案: D</p>
<p><strong>题目 18</strong><br>如果事务 T1 需要两次读取同一数据项 A，但是在两次读操作的间隔中，另一个事务 T2 改变了 A 的值，那么此并发操作所引起的问题是？</p>
<ul>
<li>选项 1: 丢失更新</li>
<li>选项 2: 死锁</li>
<li>选项 3: 不可重复读</li>
<li>选项 4: 读脏数据</li>
</ul>
<p>答案: C</p>
<p><strong>题目 19</strong><br>结构化系统分析主要是通过下列哪项进行分析的</p>
<ul>
<li>选项 1: 算法分解</li>
<li>选项 2: 控制结构分解</li>
<li>选项 3: 数据结构分解</li>
<li>选项 4: 处理功能分解</li>
</ul>
<p>答案: D</p>
<p><strong>题目 20</strong><br>结构化设计方法采用变换分析和事务分析技术实现 从数据结构导出程序结构</p>
<ul>
<li>选项 1: 从模块结构导出程序结构</li>
<li>选项 2: 从模块结构导出数据结构</li>
<li>选项 3: 从数据流图导出初始化结构图</li>
<li>选项 4: 静态存根客户端</li>
</ul>
<p>答案: D</p>
<p><strong>题目 21</strong><br>过程域对象在 Hibernate 中代表</p>
<ul>
<li>选项 1: 业务逻辑操作</li>
<li>选项 2: 应用层操作</li>
<li>选项 3: 数据库层操作</li>
<li>选项 4: 组件对象操作</li>
</ul>
<p>答案: C</p>
<p><strong>题目 22</strong><br>HQL 不支持聚合函数有?</p>
<ul>
<li>选项 1: count(*)</li>
<li>选项 2: avg(…)</li>
<li>选项 3: count(…)</li>
<li>选项 4: count(?)</li>
</ul>
<p>答案: D</p>
<p><strong>题目 23</strong><br>Under which conditions will check () return true when called from a different class?</p>
<ul>
<li>选项 1: Check() can never return true</li>
<li>选项 2: Check() can return true when setXY is called by multiple threads.</li>
<li>选项 3: “Check() can return true when multiple threads call setX and setY separately.”</li>
<li>选项 4: “Check() can only return true if SyncTest is changed to allow x and y to be set separately.”</li>
</ul>
<p>答案: CD</p>
<p><strong>题目 24</strong><br>对实际应用问题建立数学模型并求得结果后，还需要根据建模的目的和要求，利用相关知识，结合研究对象的特点，进行模型分析。 模型分析工作一般不包括</p>
<ul>
<li>选项 1: 模型的合理性分析</li>
<li>选项 2: 模型的误差分析</li>
<li>选项 3: 模型的先进性分析</li>
<li>选项 4: 参数的灵敏性分析</li>
</ul>
<p>答案: C</p>
<p><strong>题目 25</strong><br>在软件开发过程中，如果项目的规模和工作量大，项目具有较大的开发团队，需求存在明显的优先级划分或系统具有较技术风险，则最时候使用哪种生命周期？</p>
<ul>
<li>选项 1: 增量模型</li>
<li>选项 2: 快速原型</li>
<li>选项 3: 瀑布模型</li>
<li>选项 4: 螺旋模型</li>
</ul>
<p>答案: A</p>
<p><strong>题目 26</strong><br>我国《计算机软件保护条例》所称的“发表”的含义是指将软件作品</p>
<ul>
<li>选项 1: 出版发行</li>
<li>选项 2: 公之于众</li>
<li>选项 3: 在版权局登记</li>
<li>选项 4: 以某种物质形式固定下来</li>
</ul>
<p>答案: B</p>
<p><strong>题目 27</strong><br>编写 Servlet 的 doPost 方法时，需要抛出异常为</p>
<ul>
<li>选项 1: ServletException, IOException</li>
<li>选项 2: ServletException, RemoteException</li>
<li>选项 3: HttpServletException, IOException</li>
<li>选项 4: HttpServletException, RemoteException</li>
</ul>
<p>答案: A</p>
<p><strong>题目 28</strong><br>J2EE 中，哪个类的什么方法用于创建对话</p>
<ul>
<li>选项 1: HttpServletRequest 的 getSession</li>
<li>选项 2: HttpServletResponse 的 newSession</li>
<li>选项 3: HttpSession 的 newInstance</li>
<li>选项 4: HttpSession 的 getSession</li>
</ul>
<p>答案: A</p>
<p>**题目</p>
<p>29**<br>以下从四种不同的作用域中得到 Bean 的实例，说法错误的是</p>
<ul>
<li>选项 1: page 是指当前 Web 应用程序的所有 JSP 文件中取得实例，从 Page 对象中获取 JavaBean</li>
<li>选项 2: request 是指在当前的用户请求中取得实例，从 ServletRequest 对象中获取 JavaBean</li>
<li>选项 3: session 是指在当前的用户会话中取得实例，常用于一个用户登录在网站上全过程不同请求之间共享数据，从 HttpSession 对象中获取 JavaBean</li>
<li>选项 4: application 是指在当前的应用程序中取得实例，常用于同一个应用程序不同用户访问时共享数据，从 ServletContext 对象中获取 JavaBean</li>
</ul>
<p>答案: A</p>
<p><strong>题目 30</strong><br>企业在做计划时，应优先保证下列哪一组计划</p>
<ul>
<li>选项 1: 局部计划、作业计划、长期计划</li>
<li>选项 2: 项目计划、管理计划、短期计划</li>
<li>选项 3: 综合计划、战略计划、长期计划</li>
<li>选项 4: 局部计划、战略计划、中期计划</li>
</ul>
<p>答案: C</p>
<p><strong>题目 31</strong><br>计划职能的主要任务就是确定</p>
<ul>
<li>选项 1: 组织的目标和实现目标的途径</li>
<li>选项 2: 组织结构的蓝图</li>
<li>选项 3: 组织中的工作设计</li>
<li>选项 4: 组织的领导方式</li>
</ul>
<p>答案: A</p>
<p><strong>题目 32</strong><br>能有效地监督组织各项计划的落实和执行情况，发现计划与实际之间的差距，这一管理环节是</p>
<ul>
<li>选项 1: 计划</li>
<li>选项 2: 组织</li>
<li>选项 3: 领导</li>
<li>选项 4: 控制</li>
</ul>
<p>答案: D</p>
<p><strong>题目 33</strong><br>不同的数据库管理系统支持不同的数据模型，下列哪种不属于常用的数据模型？</p>
<ul>
<li>选项 1: 关系模型</li>
<li>选项 2: 网状模型</li>
<li>选项 3: 层次模型</li>
<li>选项 4: 链表模型</li>
</ul>
<p>答案: D</p>
<p><strong>题目 34</strong><br>数据流图（DFD）是用于描述结构化方法中（ ) 阶段的工具</p>
<ul>
<li>选项 1: 可行性分析</li>
<li>选项 2: 详细设计</li>
<li>选项 3: 需求分析</li>
<li>选项 4: 程序编码</li>
</ul>
<p>答案: C</p>
<p><strong>题目 35</strong><br>下面关于远程接口描述正确的是</p>
<ul>
<li>选项 1: 远程接口监听客户调用的远程方法调用并重定向对服务器上的远程 RMI 服务器的调用。</li>
<li>选项 2: 用唯一名注册的远程对象的接口</li>
<li>选项 3: 其声明的方法可被客户远程地调用的接口。</li>
<li>选项 4: 声明和定义了可被客户远程地调用的方法的接口</li>
</ul>
<p>答案: C</p>
<p><strong>题目 36</strong><br>用以下方法中哪一个把目标应用作为 bean 激活的定制事件的监听者（listener）注册</p>
<ul>
<li>选项 1: void addPropertyChangeListener()</li>
<li>选项 2: void firePropertyChange()</li>
<li>选项 3: removeXXXListener()</li>
<li>选项 4: void addXXXListener()</li>
</ul>
<p>答案: D</p>
<p><strong>题目 37</strong><br>在 J2EE 中，对于 Httpservlet 类的描述，错误的是？</p>
<ul>
<li>选项 1: 我们自己编写的 Servlet 继承了 Httpservlet 类，一定需覆盖 doPost 或者 doGet</li>
<li>选项 2: HttpServlet 类扩展了 GenericServlet 类，实现了 GenericServlet 类的抽象方法</li>
<li>选项 3: HttpServlet 类中处理客户请求和响应时所使用的两个接口是：HttpServletRequest 和 HttpServletResponse</li>
<li>选项 4: 我们自己编写的 servlet 继承了 Httpservlet 类，一般只需要覆盖 doPost 方法，不必覆盖 service（）方法，因为一个 service（）方法会调用 doPost 或者 doGet 方法</li>
</ul>
<p>答案: A</p>
<p><strong>题目 38</strong><br>下面关于合同变更与变更前后合同之间关系的正确说法是</p>
<ul>
<li>选项 1: 合同变更后，已经履行的债务失去了法律依据，应该恢复原状</li>
<li>选项 2: 合同变更部分条款后，未变更的部分视为已经变更</li>
<li>选项 3: 合同变更后，已经存在的损害赔偿请求权不复存在</li>
<li>选项 4: 合同变更必须以原合同关系存在为前提</li>
</ul>
<p>答案: D</p>
<p><strong>题目 39</strong><br>哪种应用类型在分离的层次上处理表示逻辑、业务逻辑、及数据库的可交互性？</p>
<ul>
<li>选项 1: 分布应用</li>
<li>选项 2: 以服务器为中心的应用</li>
<li>选项 3: 客户&#x2F;服务器应用</li>
<li>选项 4: 单块应用</li>
</ul>
<p>答案: A</p>
<p><strong>题目 40</strong><br>下面关于数据持久化概念的描述，错误的是</p>
<ul>
<li>选项 1: 保存在内存中数据的状态是瞬时状态</li>
<li>选项 2: 持久状态的数据在关机后数据依然存在</li>
<li>选项 3: 数据可以由持久状态转换为瞬时状态</li>
<li>选项 4: 将数据转换为持久状态的机制称为数据持久化</li>
</ul>
<p>答案: B</p>
<p>以下是您提供的多选题的整理，按照题目、选项和答案的格式：</p>
<h3 id="多选题"><a href="#多选题" class="headerlink" title="多选题"></a>多选题</h3><p><strong>题目 1</strong>:<br>Which two statements are true regarding the creation of a default constructor?</p>
<p><strong>选项</strong>:<br>A. The default constructor initializes method variables.<br>B. The compiler always creates a default constructor for every class.<br>C. The default constructor initializes the instance variables declared in the class.<br>D. “When a class has only constructors with parameters, the compiler does not create a default constructor.”</p>
<p><strong>答案</strong>: C, D</p>
<p><strong>题目 2</strong>:<br>MVC 模式的优势有哪些?</p>
<p><strong>选项</strong>:<br>A. MVC 模式使应用程序的结构更加清晰，通过将代码按照层次划分为业务逻辑&#x2F;数据层、用户界面和应用流程控制这三个层次，能够增强代码的稳定性.<br>B. MVC 模式实现了很好的分布式组件架构.<br>C. 对于项目开发而言，MVC 三层的分离有利于在项目小组内按照小组成员各自的擅长进行分工，有利于三个部分并行开发、加快项目进度.<br>D. MVC 模块功能的划分有利于在代码修改过程中进行模块的隔离，而不需要把具有不同功能的代码混杂在一起造成混乱.</p>
<p><strong>答案</strong>: A, C, D</p>
<p><strong>题目 3</strong>:<br>使用 JavaBean 的好处有哪些?</p>
<p><strong>选项</strong>:<br>A. JavaBean 拥有标准化接口的优点，在开发期有可视化编程工具的支持，在运行期有 JSP 和 J2EE 连接器的支持.<br>B. JavaBean 更明确的把 WEB 页面的设计和软件的设计区分开来.<br>C. JavaBean 可以在多个应用程序中重用.<br>D. JavaBean 可以实现安全性、事务行为、并发性和持久性.</p>
<p><strong>答案</strong>: A, B, C</p>
<p><strong>题目 4</strong>:<br>属于推动我国 ITO 发展的因素有?</p>
<p><strong>选项</strong>:<br>A. 价格优势明显.<br>B. 印度示范影响.<br>C. 通过认证企业增多.<br>D. 著名跨国企业示范.</p>
<p><strong>答案</strong>: A, B, C, D</p>
<p><strong>题目 5</strong>:<br>计划工作是一种最基本管理活动，应遵循的原则有：</p>
<p><strong>选项</strong>:<br>A. 改变航道原则.<br>B. 限定因素原则.<br>C. 承诺原则.<br>D. 弹性原则.</p>
<p><strong>答案</strong>: A, B, C, D</p>
<p><strong>题目 6</strong>:<br>一般情况下，关系数据模型与对象模型之间有哪些匹配关系</p>
<p><strong>选项</strong>:<br>A. 表对应类.<br>B. 记录对应对象.<br>C. 表的字段对应类的属性.<br>D. 表之间的参考关系对应类之间的依赖关系.</p>
<p><strong>答案</strong>: A, C, D</p>
<p><strong>题目 7</strong>:<br>weblogic 与 EJB 相关的部署描述文件有</p>
<p><strong>选项</strong>:<br>A. ejb-jar.xml.<br>B. weblogic-ejb-jar.xml.<br>C. weblogic.xml.<br>D. weblogic-cmp-rdbms-jar.xml.</p>
<p><strong>答案</strong>: A, B, D</p>
<p><strong>题目 8</strong>:<br>下面不是 Hibernate 映射文件中包含的内容？</p>
<p><strong>选项</strong>:<br>A. 数据库连接信息.<br>B. Hibernate 属性参数.<br>C. 主键生成策略.<br>D. 属性数据类型.</p>
<p><strong>答案</strong>: A, B</p>
<p><strong>题目 9</strong>:<br>下列属于外包特征的是</p>
<p><strong>选项</strong>:<br>A. 企业的各项活动可以在时间并行，空间上分散进行.<br>B. 企业把某些业务转移给外部操作，是自身组织结构扁平化.<br>C. 依托信息技术与外部资源整合.<br>D. 企业在规模收缩中扩张.</p>
<p><strong>答案</strong>: A, C, D</p>
<p><strong>题目 10</strong>:<br>管理者要使自己主管的工作达到一定的标准和要求，必须具备管理所需的相应管理技能。这些管理技能主要包括</p>
<p><strong>选项</strong>:<br>A. 领导技能.<br>B. 技术技能.<br>C. 人际技能.<br>D. 概念技能.</p>
<p><strong>答案</strong>: B, C, D</p>
<p>希望这有助于您。如果您还有其他问题或需要进一步的帮助，请随时告诉我。</p>
<h3 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h3><table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody><tr>
<td>在 JPQA 查询中，排除相同的对象用 distinct。</td>
<td>√</td>
</tr>
<tr>
<td>Bean 的事件是 java.util.EventObject 的子类。</td>
<td>√</td>
</tr>
<tr>
<td>Service()方法表示 Servlet 生命周期的结束。</td>
<td>×</td>
</tr>
<tr>
<td>ServletContext 类的 getRequestDispatcher()可以接受相对路径。</td>
<td>×</td>
</tr>
<tr>
<td>使用 Session 的 delete()会把对象的状态从数据库中移除。</td>
<td>√</td>
</tr>
<tr>
<td>在 Hibernate 中，有通用的数据库方言可以使用。</td>
<td>×</td>
</tr>
<tr>
<td>SessionFactory 是重量级的对象，不应该随意创建。如果系统中只有一个数据库存储源，只需要创建一个。</td>
<td>√</td>
</tr>
<tr>
<td>对原生 SQL 查询的控制是通过 Query 接口进行的。</td>
<td>×</td>
</tr>
<tr>
<td>专业技术人员在创新开始最为关键的环节是确认创新的机会，其战略意识和市场意识是创新获得成功的重要基础。</td>
<td>√</td>
</tr>
<tr>
<td>计划是一种约束，会降低组织的灵活性。</td>
<td>×</td>
</tr>
</tbody></table>
<p>​</p>
<h3 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h3><ol>
<li>Hibernate 处理事务的接口是 <strong>（Transaction）</strong>。</li>
<li>Struts 2 以 <strong>（FilterDispatcher）</strong> 为核心控制器。</li>
<li>构建 Struts 2 应用的最基础的几个类库是：struts2-core、commons-logging、 <strong>（xwork-core）</strong> 、freamarker 以及 ognl。</li>
<li>控制共享资源的并发访问，需要用到的 java 关键字是 <strong>（synchronized）</strong>。</li>
<li>数据库关系模型中，数据联系是通过表间的 <strong>（关键码）</strong> 实现的。</li>
<li>一般来说，在管理软件中，软件生存周期各个阶段的工作量以 <strong>（维护阶段）</strong> 所占的比例最大。</li>
<li>数据库封锁技术中主要有两种封锁：排他型封锁和 <strong>（共享）</strong> 型封锁。</li>
<li>如果不想让实体 Bean 的某些属性映射到表的字段，用 <strong>（@Column）</strong> 注释。</li>
<li>模块内部的算法设计在结构化方法的 <strong>（详细设计）</strong> 阶段进行。</li>
<li>概念结构设计的目的是产生一个能反映 <strong>（需求）</strong> 的概念模型。</li>
</ol>
<h3 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h3><p><strong>问答题 1</strong>:<br><strong>问题</strong>: 用英文翻译以下两个句子</p>
<ol>
<li>服务提供商为了不断促进业务进程而采用的某种激励方式。当通过降低成本，提高收入或提高效率使客户受益时，服务提供商也同样受益。</li>
<li>外包合同条款的一个方面。用于描述产品归属者的变更情况以及知识产权。“知识产权”是无形资产，它包含一定程度的创造性劳动，例如软件设计等。该条款保护合同双方维护其知识产权的权力，包括使用权、出版权和复制权。</li>
</ol>
<p><strong>答案</strong>:</p>
<ol>
<li>The service provider has some form of incentive for constantly improving the business process. When the client benefits (through reduced expenses, greater revenues, or improved efficiencies), so does the service provider.</li>
<li>An aspect of the outsourcing contract’s Terms and Conditions. Specifies when any change of title to products occurs. It also specifies intellectual property rights. “Intellectual property” is intangible and involves some degree of creative effort, such as software design. This clause protects both parties’ rights to retain control over their intellectual property, including the rights to their use, publication, and copying.</li>
</ol>
<p><strong>问答题 2</strong>:<br><strong>问题</strong>: Hibernate 中持久化对象的生命周期以及各种状态直接的区别，并描述相互之间是如何转换的？</p>
<p><strong>答案</strong>:<br>Hibernate 中持久化对象的生命周期有临时态、持久态和游离态三种。</p>
<ul>
<li>处于临时态的对象主键值为空，并且未与 session 关联，数据未保存到数据库中。</li>
<li>处于持久态的对象与 session 关联起来，持久化后对象中的数据被保存到数据库中，并且主键值按照.hbm.xml 文件中配置的生成方式生成相应的值。</li>
<li>处于游离态的对象脱离了 session 的管理，是持久化后的一种状态，主键值按照.hbm.xml 文件中配置的生成方式生成相应的值。<br>当 new 一个新的对象时，该对象处于临时态。当该对象被当作 session 的参数使用的时候，该对象处于持久态。事务提交，session 关闭后，该对象处于游离态。</li>
</ul>
<p><strong>问答题 3</strong>:<br><strong>问题</strong>: 项目开发要经历了哪几个阶段？简要说明项目的体系统架构：（客户层，表示层）web 层，业务层，数据层？</p>
<p><strong>答案</strong>:<br>项目开发通常经历以下阶段：需求分析，设计，编码，测试，部署。</p>
<ul>
<li>客户层：主要是用户接口，可以是 Web 浏览器、Applet 小应用程序等，取决于客户需求。</li>
<li>表示层：表示层负责展示数据和处理用户请求，包括 HTML 静态页面、JSP 页面、Servlet 等在服务器上运行的组件。</li>
<li>业务层：业务层实现业务逻辑，服务器提供系统级服务，如事务管理、安全性等，并非控制层。</li>
<li>数据层：数据层包括数据访问对象（DAO）等，用于实现对数据的增删改查等操作。</li>
</ul>
<p><strong>问答题 4</strong>:<br><strong>问题</strong>: 简述软件外包风险的防范策略？</p>
<p><strong>答案</strong>:<br>软件外包风险是指软件外包的实施结果相对于预期目标的变动程度，即软件外包的预期收益的变动程度。软件外包双方必须增强风险防范意识，软件外包风险防范的策略主要有：</p>
<ol>
<li>制定正确的外包策略：外包前要认真分析实施外包的前提是否具备，实施软件外包的可能性有多大等。</li>
<li>准确的核算和控制外包综合成本。</li>
<li>周密的考察、确定和管理接包方。</li>
<li>强化项目单点联系管理：发包方任命专人定点管理，承接方制定专人汇报联系。</li>
<li>双方实施项目全程管理。</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试笔记</title>
    <url>/2023/08/29/%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<h3 id="Javascipt考点"><a href="#Javascipt考点" class="headerlink" title="Javascipt考点"></a>Javascipt考点</h3><h4 id="闭包（Closures）"><a href="#闭包（Closures）" class="headerlink" title="闭包（Closures）"></a>闭包（Closures）</h4><p> 解释闭包的概念、原理和用途。了解闭包如何捕获外部变量以及可能导致的内存泄漏问题。</p>
<blockquote>
<p><strong>闭包的概念：</strong> 闭包是指一个函数能够记住并访问它被创建时所处的词法作用域，即使该函数在不同的作用域中被调用，也能够访问这个词法作用域中的变量。换句话说，闭包允许函数在其声明时的作用域之外被调用，但仍然可以访问其外部作用域的变量。</p>
<p><strong>闭包的原理：</strong> 当一个函数被定义时，它会捕获所在作用域的变量，将这些变量保存在自己的闭包中。这意味着在函数内部可以访问外部作用域中的变量。当函数返回后，它的闭包仍然保持对外部作用域的引用，因此这些变量不会被垃圾回收机制清除，直到闭包不再被引用。</p>
<p><strong>闭包的用途：</strong> 闭包在JavaScript中有许多有用的用途，包括：</p>
<ol>
<li><strong>数据封装和私有性：</strong> 通过闭包，可以创建私有变量和方法，将数据隐藏在函数作用域内，只通过暴露的接口访问，实现了信息的封装和隐藏。</li>
<li><strong>模块化和命名空间：</strong> 通过闭包可以创建模块，将相关的功能封装在一个函数内部，避免命名冲突和全局变量污染。</li>
<li><strong>回调函数：</strong> 在异步编程中，闭包可以用作回调函数，捕获外部作用域的状态，使得回调函数能够访问正确的数据。</li>
<li><strong>高阶函数：</strong> 闭包可以用于创建高阶函数，即接受一个或多个函数作为参数或返回一个函数的函数。</li>
</ol>
<p><strong>闭包捕获外部变量：</strong> 闭包捕获了它被创建时所处的词法作用域中的变量。这意味着函数内部引用的外部变量，即使函数在其他地方被调用，它也能够访问这些变量。</p>
<p><strong>内存泄漏问题：</strong> 闭包可以导致内存泄漏问题，特别是在不正确使用闭包的情况下。如果闭包长时间持有对外部作用域中大量变量的引用，这些变量将不会被垃圾回收，从而导致内存泄漏。为避免内存泄漏，需要在不再需要闭包时，手动解除对外部变量的引用，或者使用适当的垃圾回收策略。</p>
</blockquote>
<h5 id="闭包垃圾回收策略"><a href="#闭包垃圾回收策略" class="headerlink" title="闭包垃圾回收策略"></a>闭包垃圾回收策略</h5><p>闭包内存泄漏是由于闭包持有对外部变量的引用，导致这些变量无法被垃圾回收，从而造成内存泄漏。下面是一些解决闭包内存泄漏的方法：</p>
<p><strong>1. 避免不必要的闭包：</strong> 尽量避免在不需要的情况下创建闭包。只有当确实需要保留状态或行为时，才应使用闭包。</p>
<p><strong>2. 及时解除引用：</strong> 在不再需要闭包时，手动将闭包引用的外部变量赋值为<code>null</code>，从而解除对外部变量的引用，使其能够被垃圾回收。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createClosure</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> data = <span class="string">&quot;Some data&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建闭包</span></span><br><span class="line">  <span class="keyword">var</span> closure = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在适当的时机解除引用</span></span><br><span class="line">  closure = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> closure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3. 使用事件委托：</strong> 当处理事件监听器时，使用事件委托来避免每个元素都有一个闭包。将事件监听器绑定到父元素，通过事件冒泡捕获事件，这样只会创建一个闭包。</p>
<p><strong>4. 使用块级作用域：</strong> 使用块级作用域（<code>let</code>、<code>const</code>）代替函数作用域（<code>var</code>），因为块级作用域在离开块后会自动解除引用。</p>
<p><strong>5. 将闭包变量设为不可配置：</strong> 使用<code>Object.defineProperty</code>将闭包中的变量设置为不可配置、不可写，这样在某些情况下会帮助解除引用。</p>
<p><strong>6. 使用模块化：</strong> 使用模块化的方式来组织代码，限制闭包的作用域，避免不必要的变量引用。</p>
<p><strong>7. 使用垃圾回收工具：</strong> 使用现代的开发工具和调试工具来检测和诊断内存泄漏，例如 Chrome DevTools 的 Memory 面板。</p>
<h4 id="作用域和作用域链（Scope-and-Scope-Chain）"><a href="#作用域和作用域链（Scope-and-Scope-Chain）" class="headerlink" title="作用域和作用域链（Scope and Scope Chain）"></a>作用域和作用域链（Scope and Scope Chain）</h4><p> 解释词法作用域、函数作用域、块级作用域和变量提升。描述作用域链的概念，以及变量查找的顺序。</p>
<blockquote>
<p><strong>词法作用域（Lexical Scope）：</strong><br>词法作用域是指变量的可见性和访问规则是在代码编写阶段就确定的，而不是在运行时确定的。JavaScript使用词法作用域来决定在何处查找变量。</p>
<p><strong>函数作用域：</strong><br>函数作用域是指变量的可见性仅限于函数内部。在函数内部定义的变量对函数外部是不可见的，但函数内部可以访问外部作用域中的变量。</p>
<p><strong>块级作用域：</strong><br>块级作用域是指变量的可见性仅限于包含变量声明的代码块内部（通常是由花括号 <code>&#123;&#125;</code> 包围的部分）。在ES6之前，JavaScript没有块级作用域，但通过<code>var</code>声明的变量会在整个函数作用域中生效。</p>
<p><strong>变量提升：</strong><br>变量提升是指在代码执行前，JavaScript引擎会将变量的声明部分提升到作用域的顶部，但不会提升变量的赋值部分。这意味着你可以在变量声明之前访问变量，但值会是<code>undefined</code>。</p>
<p><strong>作用域链的概念：</strong><br>作用域链是指由多个嵌套作用域构成的链式结构。每个作用域都保持一个对其父级作用域的引用，形成了一个作用域链。当访问一个变量时，JavaScript引擎首先在当前作用域中查找，如果找不到，它会向上一级作用域查找，依此类推，直到找到变量或到达全局作用域。</p>
<p><strong>变量查找的顺序：</strong><br>当访问一个变量时，JavaScript引擎会按照以下顺序查找：</p>
<ol>
<li>首先，在当前作用域中查找变量。</li>
<li>如果在当前作用域中找不到变量，则向上一级作用域查找，依此类推，直到找到变量或到达全局作用域。</li>
<li>如果在全局作用域中仍然找不到变量，JavaScript会抛出一个<code>ReferenceError</code>错误。</li>
</ol>
<p>下面是一个示例，演示了词法作用域、函数作用域、块级作用域和变量提升的概念：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVar = <span class="string">&quot;Global&quot;</span>; <span class="comment">// 全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> functionVar = <span class="string">&quot;Function Scope&quot;</span>; <span class="comment">// 函数作用域</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> blockVar = <span class="string">&quot;Block Scope&quot;</span>; <span class="comment">// 块级作用域（在ES6之前没有）</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(globalVar); <span class="comment">// 可访问</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(functionVar); <span class="comment">// 可访问</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(blockVar); <span class="comment">// 可访问（在ES6之前）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(globalVar); <span class="comment">// 可访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(functionVar); <span class="comment">// 不可访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(blockVar); <span class="comment">// 不可访问</span></span><br></pre></td></tr></table></figure></div>

</blockquote>
<h4 id="原型和原型链（Prototype-and-Prototype-Chain）"><a href="#原型和原型链（Prototype-and-Prototype-Chain）" class="headerlink" title="原型和原型链（Prototype and Prototype Chain）"></a>原型和原型链（Prototype and Prototype Chain）</h4><p> 详细介绍原型、构造函数、原型链和继承。解释原型继承和使用<code>prototype</code>和<code>__proto__</code>的区别。</p>
<blockquote>
<p><strong>原型（Prototype）：</strong></p>
<p>原型是JavaScript中对象之间继承关系的基础。每个JavaScript对象都有一个原型对象，它包含了一些共享的属性和方法。对象可以通过原型链来访问原型对象中的属性和方法。原型关系是通过引用来建立的。</p>
<p><strong>构造函数（Constructor）：</strong><br>构造函数是用于创建对象的函数，通常以大写字母开头，例如<code>Person</code>。当通过构造函数使用<code>new</code>关键字创建一个对象实例时，实例会自动继承构造函数的原型对象上的属性和方法。</p>
<p><strong>原型链（Prototype Chain）：</strong><br>原型链是由一系列对象及其原型对象所组成的链式结构，用于属性和方法的查找。当访问一个对象的属性或方法时，JavaScript会从对象自身开始查找，如果找不到，则沿着原型链向上查找，直到找到属性或方法或者到达原型链的顶端（<code>Object.prototype</code>）。</p>
<p><strong>继承：</strong><br>继承是指一个对象可以获得另一个对象的属性和方法，以实现代码的重用和组织。在JavaScript中，继承通过原型链来实现。子对象可以通过原型链访问父对象的属性和方法，实现了继承关系。</p>
<p><strong>原型继承：</strong><br>原型继承是一种基于原型链的继承方式。一个对象可以通过将另一个对象设置为其原型，从而继承另一个对象的属性和方法。这样，子对象可以通过原型链访问父对象的属性和方法。</p>
<p><strong>使用<code>prototype</code>和<code>__proto__</code>的区别：</strong></p>
<ul>
<li><p><code>prototype</code>：每个函数都有一个<code>prototype</code>属性，它指向一个对象，这个对象会成为通过该构造函数创建的实例的原型。通过在构造函数上设置原型属性，可以添加共享的属性和方法。这种方式用于定义实例的原型，实现方法的共享。</p>
</li>
<li><p><code>__proto__</code>：<code>__proto__</code>是每个对象都具有的属性，它指向对象的原型。通过<code>__proto__</code>可以访问和修改对象的原型。但是，应该尽量避免直接使用<code>__proto__</code>，因为它是非标准的属性，在某些情况下可能不受支持。</p>
</li>
</ul>
<p>综上所述，原型、构造函数、原型链和继承是JavaScript中重要的概念，它们共同构成了对象之间的关系和继承机制。通过使用构造函数和原型，可以实现对象的属性和方法的共享和继承，从而使代码更加模块化和可维护。</p>
</blockquote>
<h4 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h4><p> 解释this在不同情境下的指向，包括普通函数、箭头函数、构造函数、事件处理函数等。理解this的动态绑定机制。</p>
<blockquote>
<p><code>this</code> 是 JavaScript 中一个非常重要的关键字，它指向当前函数执行的上下文对象。<code>this</code> 的指向在不同的情境下有不同的行为，下面解释了在不同情境下 <code>this</code> 的指向：</p>
<ol>
<li><p><strong>普通函数：</strong><br>在普通函数中，<code>this</code> 的指向取决于函数的调用方式。如果函数是作为普通函数调用，<code>this</code> 指向全局对象（在浏览器环境中是 <code>window</code> 对象）。但是在严格模式下，<code>this</code> 指向 <code>undefined</code>。</p>
</li>
<li><p><strong>箭头函数：</strong><br>箭头函数中的 <code>this</code> 是词法作用域中的 <code>this</code>，它不会被动态绑定，而是在函数定义时就确定了。箭头函数的 <code>this</code> 始终指向最近一层非箭头函数的上下文。这意味着箭头函数没有自己的 <code>this</code>，它继承外部作用域的 <code>this</code>。</p>
</li>
<li><p><strong>构造函数：</strong><br>在构造函数中，<code>this</code> 指向正在创建的新对象。当使用 <code>new</code> 关键字调用构造函数时，<code>this</code> 将绑定到新创建的对象实例。</p>
</li>
<li><p><strong>事件处理函数：</strong><br>在事件处理函数中，<code>this</code> 指向触发事件的元素（DOM 元素），这是一种常见的情况，比如点击事件处理函数中的 <code>this</code> 指向被点击的元素。</p>
</li>
<li><p><strong>方法调用：</strong><br>在对象方法中，<code>this</code> 指向调用方法的对象本身。这种情况下，<code>this</code> 通常用于访问对象的属性和方法。</p>
</li>
</ol>
<p><strong>动态绑定机制：</strong><br><code>this</code> 的指向是动态绑定的，它在函数被调用时确定，而不是在函数定义时确定。这意味着 <code>this</code> 的指向可以根据函数的调用方式和上下文发生变化。</p>
<p>在 JavaScript 中，函数的调用方式包括四种：函数调用、方法调用、构造函数调用和通过 <code>call</code>、<code>apply</code>、<code>bind</code> 方法进行调用。每种调用方式都会影响 <code>this</code> 的指向。</p>
<p>理解 <code>this</code> 的指向和动态绑定机制对于编写正确且易于维护的 JavaScript 代码非常重要。掌握不同情境下 <code>this</code> 的行为可以帮助避免错误并更好地控制代码的执行逻辑。</p>
</blockquote>
<p><strong>1. 在全局作用域中：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 在浏览器中输出：Window 对象，在Node.js中输出：global 对象</span></span><br></pre></td></tr></table></figure></div>

<p><strong>2. 作为函数调用：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myFunction</span>(); <span class="comment">// 在浏览器中输出：Window 对象，在Node.js中输出：global 对象（非严格模式下）</span></span><br></pre></td></tr></table></figure></div>

<p><strong>3. 作为方法调用：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">  <span class="attr">greet</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">greet</span>(); <span class="comment">// 输出：Hello, my name is Alice</span></span><br></pre></td></tr></table></figure></div>

<p><strong>4. 使用<code>call</code>和<code>apply</code>方法显式指定<code>this</code>：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">greet.<span class="title function_">call</span>(person1); <span class="comment">// 输出：Hello, my name is Alice</span></span><br><span class="line">greet.<span class="title function_">apply</span>(person2); <span class="comment">// 输出：Hello, my name is Bob</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>call</code>、<code>apply</code>和<code>bind</code>是 JavaScript 中用于显式绑定函数中的<code>this</code>值的方法。它们在不同情况下提供了对函数的不同方式调用，以及指定函数内部<code>this</code>的能力。</p>
<p><strong>1. <code>call</code>方法：</strong><br><code>call</code>方法用于调用函数，第一个参数是函数内部的<code>this</code>值，后面的参数是函数的参数列表。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;message&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Alice&quot;</span> &#125;;</span><br><span class="line">greet.<span class="title function_">call</span>(person, <span class="string">&quot;Hello&quot;</span>); <span class="comment">// 输出：Hello, Alice</span></span><br></pre></td></tr></table></figure></div>

<p><strong>2. <code>apply</code>方法：</strong><br><code>apply</code>方法与<code>call</code>类似，但是参数需要放在一个数组中传递。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;message&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Bob&quot;</span> &#125;;</span><br><span class="line">greet.<span class="title function_">apply</span>(person, [<span class="string">&quot;Hi&quot;</span>]); <span class="comment">// 输出：Hi, Bob</span></span><br></pre></td></tr></table></figure></div>

<p><strong>3. <code>bind</code>方法：</strong><br><code>bind</code>方法用于创建一个新的函数，并将其中的<code>this</code>绑定到指定的值，可以在稍后调用该函数。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;message&#125;</span>, <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">&quot;Charlie&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> greetPerson = greet.<span class="title function_">bind</span>(person);</span><br><span class="line"><span class="title function_">greetPerson</span>(<span class="string">&quot;Hey&quot;</span>); <span class="comment">// 输出：Hey, Charlie</span></span><br></pre></td></tr></table></figure></div>

<p>这些方法允许开发者显式地控制函数中<code>this</code>的值，以及提供参数调用函数。选择适当的方法取决于具体的使用情况和需求。</p>
</blockquote>
<p><strong>5. 作为构造函数调用：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 输出：Person &#123; name: &#x27;Alice&#x27; &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>6. 箭头函数中的<code>this</code>：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">func</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 输出：&#123; func: [Function: func] &#125;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="title function_">arrowFunc</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 输出：&#123; func: [Function: func] &#125;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_">arrowFunc</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">func</span>();</span><br></pre></td></tr></table></figure></div>

<p><strong><code>this</code>的原理：</strong><br><code>this</code>的值由函数的调用方式决定，而不是函数的定义方式。以下是一些原则：</p>
<ol>
<li><p><strong>默认绑定：</strong> 在全局作用域中，<code>this</code>指向全局对象（浏览器中是<code>Window</code>，Node.js中是<code>global</code>）。在普通函数中，<code>this</code>同样指向全局对象（非严格模式下）。</p>
</li>
<li><p><strong>隐式绑定：</strong> 当函数作为对象的方法调用时，<code>this</code>指向调用该函数的对象。</p>
</li>
<li><p><strong>显式绑定：</strong> 使用<code>call</code>、<code>apply</code>、<code>bind</code>方法，可以显式指定函数中的<code>this</code>。</p>
</li>
<li><p><strong>构造函数中的绑定：</strong> 当使用<code>new</code>关键字调用构造函数创建对象时，<code>this</code>会绑定到新创建的对象。</p>
</li>
<li><p><strong>箭头函数中的绑定：</strong> 箭头函数中的<code>this</code>由外围（定义箭头函数的函数或作用域）的<code>this</code>决定，而不是运行时调用的对象。</p>
</li>
</ol>
<p>理解这些原则有助于更好地理解<code>this</code>的行为，避免出现意外的结果。</p>
<h4 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h4><p>解释回调函数、Promise、async&#x2F;await、Generator等异步编程模式。了解事件循环（Event Loop）和宏任务与微任务的区别。</p>
<blockquote>
<p>异步编程是指在程序执行过程中，某些操作不会阻塞程序的执行，而是在后台执行，以提高程序的效率和响应性。以下是几种常见的异步编程模式：</p>
<ol>
<li><p><strong>回调函数：</strong> 回调函数是一种通过将函数作为参数传递给另一个函数，在异步操作完成后执行的方式。经典的回调地狱问题是多个嵌套的回调函数难以管理和维护。</p>
</li>
<li><p><strong>Promise：</strong> Promise 是一种用于处理异步操作的对象，它表示一个可能完成或失败的操作，并提供了更加结构化的异步编程方式。通过 <code>then</code> 方法可以在操作完成后执行成功或失败的回调。</p>
</li>
<li><p><strong>async&#x2F;await：</strong> <code>async</code> 函数是异步操作的新的语法糖，它可以让你像编写同步代码一样处理异步操作。<code>await</code> 关键字用于等待一个 Promise 完成，并返回结果。</p>
</li>
<li><p><strong>Generator：</strong> Generator 是一种特殊类型的函数，可以在运行中暂停并在需要时恢复执行。通过 <code>yield</code> 关键字可以暂停函数的执行，而通过迭代器可以在每次调用 <code>next</code> 时恢复执行。</p>
</li>
</ol>
<p><strong>事件循环（Event Loop）：</strong><br>事件循环是 JavaScript 异步编程的基础机制，它允许程序在单线程中处理多个任务。JavaScript 引擎中存在一个事件循环，它会不断地从任务队列中获取任务并执行。</p>
<p><strong>宏任务与微任务的区别：</strong><br>事件循环中的任务分为两种类型：宏任务（macrotask）和微任务（microtask）。</p>
<ul>
<li><p><strong>宏任务（macrotask）：</strong> 宏任务包括整体代码块、setTimeout、setInterval、I&#x2F;O 操作等。宏任务会在事件循环的不同阶段执行，它们会被排队并在主线程空闲时执行。</p>
</li>
<li><p><strong>微任务（microtask）：</strong> 微任务包括 Promise 的回调、MutationObserver 和 process.nextTick 等。微任务会在宏任务执行完毕后立即执行，在事件循环的当前阶段中执行，不会被推迟。</p>
</li>
</ul>
<p>事件循环的过程是这样的：首先执行当前宏任务，然后检查是否有微任务需要执行，如果有，执行微任务直到清空微任务队列，然后继续执行下一个宏任务，以此类推。</p>
<p>总结：异步编程模式有多种，它们用于处理非阻塞的操作，以提高程序的性能和响应性。事件循环是 JavaScript 异步编程的核心机制，它通过宏任务和微任务的处理，实现了单线程环境下的多任务处理。</p>
</blockquote>
<h4 id="Event-Bubbling和Event-Capturing"><a href="#Event-Bubbling和Event-Capturing" class="headerlink" title="Event Bubbling和Event Capturing"></a>Event Bubbling和Event Capturing</h4><p> 解释事件冒泡和事件捕获的机制。了解如何阻止事件传播和取消默认行为。</p>
<blockquote>
<p>事件冒泡（Event Bubbling）和事件捕获（Event Capturing）是指在DOM结构中，当一个元素上的事件被触发时，事件会沿着其父级元素一直传播或捕获的过程。</p>
<p><strong>事件冒泡机制：</strong><br>事件冒泡是指当一个元素上的事件被触发时，事件会从内向外依次传播到父元素，直至达到文档的根元素。比如，当点击一个按钮时，按钮的点击事件会首先触发按钮自身的事件处理函数，然后逐级向上触发父级元素的事件处理函数。</p>
<p><strong>事件捕获机制：</strong><br>事件捕获是指当一个元素上的事件被触发时，事件会从文档根元素开始，沿着DOM树从外向内传播，直到达到事件触发元素。比如，当点击一个按钮时，事件会首先从文档根元素开始捕获，逐级向下，直到达到按钮元素，然后触发按钮的事件处理函数。</p>
<p><strong>阻止事件传播和取消默认行为：</strong></p>
<ol>
<li><p><strong>阻止事件传播（Stop Propagation）：</strong> 可以使用 <code>event.stopPropagation()</code> 方法阻止事件继续传播，无论是冒泡阶段还是捕获阶段。这会阻止其他祖先或子孙元素上的事件处理函数被触发。</p>
</li>
<li><p><strong>取消默认行为（Prevent Default）：</strong> 可以使用 <code>event.preventDefault()</code> 方法取消浏览器默认的事件行为。例如，点击链接时阻止页面跳转、在表单提交时阻止页面刷新等。</p>
</li>
</ol>
<p>示例代码如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;parent&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Parent clicked&quot;</span>);</span><br><span class="line">  <span class="comment">// event.stopPropagation(); // 阻止事件冒泡</span></span><br><span class="line">&#125;, <span class="literal">true</span>); <span class="comment">// 第三个参数表示在捕获阶段触发事件</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;child&quot;</span>).<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Child clicked&quot;</span>);</span><br><span class="line">  <span class="comment">// event.stopPropagation(); // 阻止事件冒泡</span></span><br><span class="line">  <span class="comment">// event.preventDefault(); // 取消默认行为</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>通过理解事件冒泡和捕获机制，以及如何阻止事件传播和取消默认行为，你可以更好地控制和处理DOM元素上的事件，实现更复杂的交互效果。</p>
</blockquote>
<h4 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h4><p> 解释如何通过JavaScript操作DOM元素，包括查找元素、修改属性、添加&#x2F;删除元素等。注意性能问题和重绘回流。</p>
<blockquote>
<p>通过JavaScript操作DOM元素是实现动态网页交互的重要部分。以下是一些常见的DOM操作以及与性能相关的注意事项：</p>
<p><strong>查找元素：</strong></p>
<ol>
<li><strong>getElementById：</strong> 使用元素的ID获取一个单一元素。</li>
<li><strong>querySelector：</strong> 使用CSS选择器获取匹配的第一个元素。</li>
<li><strong>querySelectorAll：</strong> 使用CSS选择器获取匹配的所有元素。</li>
<li><strong>getElementsByClassName：</strong> 使用类名获取匹配的所有元素。</li>
<li><strong>getElementsByTagName：</strong> 使用标签名获取匹配的所有元素。</li>
</ol>
<p><strong>修改属性：</strong></p>
<ol>
<li><strong>getAttribute &#x2F; setAttribute：</strong> 获取或设置元素的属性。</li>
<li><strong>classList：</strong> 使用classList对象修改元素的类名，可以添加、删除、切换类名。</li>
</ol>
<p><strong>添加&#x2F;删除元素：</strong></p>
<ol>
<li><strong>createElement：</strong> 创建新的元素节点。</li>
<li><strong>appendChild &#x2F; insertBefore：</strong> 添加新元素到现有元素中。</li>
<li><strong>removeChild：</strong> 从父元素中移除子元素。</li>
</ol>
<p><strong>性能问题和重绘回流：</strong></p>
<ol>
<li><p><strong>重绘（Repainting）：</strong> 当元素的样式属性（如颜色、背景）发生变化时，浏览器需要重新绘制元素，这称为重绘。重绘不一定导致布局的改变。</p>
</li>
<li><p><strong>回流（Reflow）：</strong> 当元素的尺寸、位置或布局发生变化时，浏览器需要重新计算布局和绘制，这称为回流。回流会导致页面重新排列，影响性能。</p>
</li>
</ol>
<p><strong>性能优化建议：</strong></p>
<ol>
<li><p><strong>批量处理：</strong> 尽量减少DOM操作，最好通过文档片段（DocumentFragment）一次性添加多个元素，减少回流次数。</p>
</li>
<li><p><strong>避免频繁访问样式和布局属性：</strong> 避免在循环中频繁读取布局属性，这可能触发多次回流。</p>
</li>
<li><p><strong>缓存DOM查询：</strong> 将查找的DOM元素存储在变量中，避免重复查找。</p>
</li>
<li><p><strong>使用classList代替直接修改className：</strong> 使用classList可以更高效地操作类名。</p>
</li>
<li><p><strong>避免强制同步布局：</strong> 获取某些属性（如offsetTop、offsetLeft、offsetWidth、offsetHeight）会触发回流，尽量避免在频繁变动中使用。</p>
</li>
<li><p><strong>使用requestAnimationFrame：</strong> 使用<code>requestAnimationFrame</code>可以优化动画等频繁的DOM操作，使它们在浏览器的下一帧绘制前执行。</p>
</li>
</ol>
<p>理解DOM操作和性能问题是开发高性能网页的关键。通过合理优化DOM操作，可以减少页面的回流和重绘，提升用户体验。</p>
</blockquote>
<h4 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h4><p>浏览器的渲染过程包括多个阶段，涵盖从接收HTML文档到展示可见内容的一系列步骤。以下是浏览器的详细渲染步骤：</p>
<p><strong>1. 解析HTML：</strong> 浏览器解析HTML文档，构建DOM（文档对象模型）树，表示页面的结构和元素关系。</p>
<p><strong>2. 构建DOM树：</strong> 浏览器根据HTML标记创建DOM树，每个标签都对应DOM树中的一个节点。</p>
<p><strong>3. 构建CSSOM（CSS对象模型）树：</strong> 浏览器解析CSS样式，创建CSSOM树，表示样式规则的层叠关系。</p>
<p><strong>4. 合并DOM和CSSOM：</strong> 浏览器将DOM树和CSSOM树合并成一个Render树，Render树描述了页面的可见内容、布局和样式。</p>
<p><strong>5. 布局（Layout）：</strong> 浏览器计算出每个元素在屏幕上的位置和大小，生成布局（盒子模型）信息。</p>
<p><strong>6. 绘制（Paint）：</strong> 浏览器将页面的可见部分绘制在内存中，生成位图。</p>
<p><strong>7. 栅格化（Rasterization）：</strong> 将绘制好的位图转换为图像块，以便渲染到屏幕上。</p>
<p><strong>8. 合成（Composite）：</strong> 浏览器将多个图像块合成为最终的屏幕图像，按照正确的层次和顺序进行合成。</p>
<p><strong>9. 渲染到屏幕：</strong> 最终的屏幕图像渲染到显示器上，用户可以看到页面内容。</p>
<p>值得注意的是，上述步骤在实际渲染过程中可能会有优化和并行处理。例如，浏览器可能会对DOM树和CSSOM树的解析进行异步操作，以提高页面加载速度。</p>
<p>整个渲染过程是一个复杂的流程，各个阶段的优化都会影响到页面的渲染性能和用户体验。理解浏览器的渲染步骤有助于开发者优化网页性能，提高用户满意度。</p>
<h4 id="内存管理和垃圾回收"><a href="#内存管理和垃圾回收" class="headerlink" title="内存管理和垃圾回收"></a>内存管理和垃圾回收</h4><p> 了解JavaScript中的垃圾回收机制，如何管理内存、避免内存泄漏，以及手动解除引用的技巧。</p>
<blockquote>
<p>JavaScript中的垃圾回收机制是自动管理内存的过程，它会检测不再使用的变量和对象，并释放其占用的内存。以下是关于垃圾回收、内存管理、避免内存泄漏和手动解除引用的详细解释：</p>
<p><strong>垃圾回收机制：</strong><br>JavaScript的垃圾回收机制主要依赖于两个主要的策略：标记清除和引用计数。</p>
<ul>
<li><p><strong>标记清除（Mark-and-Sweep）：</strong> 垃圾回收器会定期标记所有在内存中的变量，然后标记所有仍然可访问的变量。未被标记的变量被视为垃圾，可以被清除。</p>
</li>
<li><p><strong>引用计数：</strong> 引用计数是一种简单的垃圾回收方法，它跟踪每个对象被引用的次数。当一个对象的引用计数为零时，即没有变量引用它，那么它就是不可访问的，可以被回收。</p>
</li>
</ul>
<p><strong>内存管理和避免内存泄漏：</strong></p>
<ul>
<li><p><strong>正确使用变量作用域：</strong> 确保变量只在需要的范围内存在，避免变量持续存在于不需要的作用域中。</p>
</li>
<li><p><strong>显式解除引用：</strong> 当不再需要一个对象时，将其引用设置为<code>null</code>，这样垃圾回收器可以正确地判定它不再被引用。</p>
</li>
<li><p><strong>定时清除计时器：</strong> 使用<code>setTimeout</code>或<code>setInterval</code>创建的计时器可能导致内存泄漏。确保在不需要计时器时及时清除它们。</p>
</li>
<li><p><strong>避免循环引用：</strong> 循环引用是两个或多个对象相互引用，而没有任何外部引用。确保在不需要的情况下断开循环引用。</p>
</li>
</ul>
<p><strong>手动解除引用的技巧：</strong><br>手动解除引用是指在适当的时候将对象的引用设置为<code>null</code>，以确保垃圾回收器可以回收不再使用的对象。以下是一些手动解除引用的技巧：</p>
<ol>
<li><p><strong>退出函数时解除引用：</strong> 在函数内部创建的局部变量，在函数退出时会自动解除引用。确保不会在函数外部继续引用这些局部变量。</p>
</li>
<li><p><strong>清除事件监听器：</strong> 当不再需要一个元素的事件监听器时，确保将其移除，以避免元素和监听器之间的循环引用。</p>
</li>
<li><p><strong>清除计时器：</strong> 使用<code>clearTimeout</code>或<code>clearInterval</code>清除不再需要的计时器，以避免内存泄漏。</p>
</li>
<li><p><strong>清除闭包：</strong> 如果一个函数形成了闭包，确保在不再需要时解除对其变量的引用，以避免造成循环引用。</p>
</li>
</ol>
<p>通过合理的内存管理和手动解除引用，可以减少内存泄漏问题，确保程序在长时间运行中仍然具有良好的性能。</p>
</blockquote>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p> 介绍模块化的概念、CommonJS、ES6模块和导入&#x2F;导出的用法。了解模块加载器和打包工具（如Webpack）。</p>
<blockquote>
<p><strong>模块化的概念：</strong><br>模块化是一种将程序分割成独立、可复用的代码块的编程方法。它有助于将代码分解为更小的部分，提高可维护性、可读性和复用性。模块化还有助于隔离命名空间，避免全局变量污染，减少命名冲突。</p>
<p><strong>CommonJS：</strong><br>CommonJS是一种用于在服务器端和本地环境中实现模块化的规范。它定义了<code>require</code>和<code>module.exports</code>来导入和导出模块。在Node.js中，CommonJS是默认的模块系统。</p>
<p><strong>ES6模块：</strong><br>ES6（ECMAScript 2015）引入了一种原生的模块系统，支持在浏览器环境中使用模块化。ES6模块使用<code>import</code>和<code>export</code>语法来导入和导出模块。它可以在现代浏览器中直接使用，也可以通过转译工具（如Babel）在旧浏览器中使用。</p>
<p><strong>导入&#x2F;导出的用法：</strong><br>在CommonJS和ES6模块中，导入和导出模块的方式略有不同：</p>
<p><strong>CommonJS：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">key</span>: value</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable language_">module</span> = <span class="built_in">require</span>(<span class="string">&#x27;./modulePath&#x27;</span>);</span><br></pre></td></tr></table></figure></div>

<p><strong>ES6模块：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导出模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> key = value;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; key &#125; <span class="keyword">from</span> <span class="string">&#x27;./modulePath&#x27;</span>;</span><br></pre></td></tr></table></figure></div>

<p><strong>模块加载器和打包工具（如Webpack）：</strong><br>模块加载器是用于在浏览器环境中加载模块的工具，它可以将模块的依赖关系和导入关系解析成可执行的代码。常见的模块加载器包括RequireJS和SystemJS。</p>
<p>打包工具（如Webpack）是用于将多个模块打包成一个或多个文件的工具。它可以自动解析模块之间的依赖关系，并生成最终的代码包。Webpack还提供了许多功能，如代码分割、压缩、文件处理等，以优化前端项目的性能和开发流程。</p>
<p>综上所述，模块化是现代编程中的重要概念，通过将代码分割成模块，可以提高代码的可维护性和可读性。不同的模块化规范和工具可以帮助开发者更好地组织和管理项目代码。</p>
</blockquote>
<h4 id="闭包、高阶函数和函数式编程"><a href="#闭包、高阶函数和函数式编程" class="headerlink" title="闭包、高阶函数和函数式编程"></a>闭包、高阶函数和函数式编程</h4><p> 解释高阶函数、柯里化、偏函数等概念。掌握函数式编程的基本思想和应用。</p>
<blockquote>
<p><strong>高阶函数：</strong><br>高阶函数是指接受一个或多个函数作为参数，并&#x2F;或返回一个函数作为结果的函数。它们可以用于将函数抽象出来，使代码更具可复用性和灵活性。常见的高阶函数包括<code>map</code>、<code>filter</code>、<code>reduce</code>等。下面是一个简单的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 高阶函数：接受函数作为参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">applyOperation</span>(<span class="params">value, operation</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">operation</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">square</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">double</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">applyOperation</span>(<span class="number">5</span>, square)); <span class="comment">// 输出：25</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">applyOperation</span>(<span class="number">3</span>, double)); <span class="comment">// 输出：6</span></span><br></pre></td></tr></table></figure></div>



<p><strong>柯里化（Currying）：</strong><br>柯里化是将接受多个参数的函数转换为一系列只接受一个参数的函数的过程。柯里化可以使函数的组合更加灵活，可以逐步传递参数，更好地实现函数的复用。下面是一个例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curriedAdd</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add5 = <span class="title function_">curriedAdd</span>(<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add5</span>(<span class="number">3</span>)); <span class="comment">// 输出：8</span></span><br></pre></td></tr></table></figure></div>



<p><strong>偏函数：</strong><br>偏函数是指通过固定部分参数来创建一个新的函数。它可以将一个多参数函数转化为一个接受较少参数的函数。这在部分参数固定的情况下非常有用，减少了重复代码。下面是一个例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partial</span>(<span class="params">fn, x</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(x, y);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> double = <span class="title function_">partial</span>(multiply, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">double</span>(<span class="number">5</span>)); <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure></div>

</blockquote>
<h4 id="类型转换和比较"><a href="#类型转换和比较" class="headerlink" title="类型转换和比较"></a>类型转换和比较</h4><p> 解释强制类型转换、隐式类型转换、全等运算符和相等运算符的区别。理解JavaScript的数据类型。</p>
<blockquote>
<p><strong>强制类型转换：</strong><br>强制类型转换是将一个数据类型转换为另一个数据类型的过程，通常由开发者显式地执行。在JavaScript中，可以使用函数（如<code>Number()</code>、<code>String()</code>、<code>Boolean()</code>）来进行强制类型转换。</p>
<p><strong>隐式类型转换：</strong><br>隐式类型转换是在操作中自动发生的类型转换，通常由JavaScript引擎根据上下文和操作符自动执行。例如，当使用不同类型的值进行加法运算时，JavaScript会隐式地将它们转换为相同的类型再执行操作。</p>
<p><strong>全等运算符（<code>===</code>）和相等运算符（<code>==</code>）的区别：</strong></p>
<ul>
<li><p><strong>全等运算符（&#x3D;&#x3D;&#x3D;）：</strong> 它比较两个值是否相等，不仅比较值本身，还比较数据类型。只有在值和数据类型都相等时，全等运算符返回<code>true</code>。</p>
</li>
<li><p><strong>相等运算符（&#x3D;&#x3D;）：</strong> 它也比较两个值是否相等，但在比较之前会进行隐式类型转换。它会尝试将操作数转换为相同的类型，然后再比较值。因此，可能会导致一些意外的结果，例如不同类型的值被转换为相同的类型后看起来相等。</p>
</li>
</ul>
<p><strong>JavaScript的数据类型：</strong><br>JavaScript具有多种数据类型，可以分为两大类：基本数据类型（Primitive Types）和引用数据类型（Reference Types）。</p>
<blockquote>
<p><strong>判断<code>null</code>的类型</strong></p>
<p>在JavaScript中，可以使用<code>typeof</code>操作符来判断变量的类型。然而，<code>typeof</code>操作符对于<code>null</code>的返回结果可能会让人感到困惑，因为它返回的是<code>&quot;object&quot;</code>，而不是<code>&quot;null&quot;</code>。这是一个历史遗留问题。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> value); <span class="comment">// 输出：&quot;object&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>如果你需要更准确地判断变量是否为<code>null</code>，可以使用以下方法：</p>
<p><strong>1. 使用严格相等（&#x3D;&#x3D;&#x3D;）：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Value is null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>2. 使用isNull函数（自定义或使用第三方库）：</strong></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isNull</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_">isNull</span>(value)) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Value is null&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>3. 使用nullish判断（??）：</strong> 如果你想检查一个值是否为<code>null</code>或<code>undefined</code>，可以使用<code>??</code>操作符。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (value ?? <span class="string">&quot;default value&quot;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Value is not null or undefined&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Value is null or undefined&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>总之，尽管<code>typeof</code>操作符对于<code>null</code>的结果可能会有点令人困惑，但你可以使用严格相等、自定义函数或<code>??</code>操作符来更准确地判断一个值是否为<code>null</code>。</p>
</blockquote>
<p><strong>基本数据类型：</strong></p>
<ol>
<li><strong>Number：</strong> 表示数字，包括整数和浮点数。</li>
<li><strong>String：</strong> 表示字符串，由一系列字符组成。</li>
<li><strong>Boolean：</strong> 表示布尔值，只有两个值：<code>true</code>和<code>false</code>。</li>
<li><strong>Null：</strong> 表示空值。</li>
<li><strong>Undefined：</strong> 表示未定义的值。</li>
<li><strong>Symbol（ES6新增）：</strong> 表示唯一的、不可变的值。</li>
</ol>
<p><strong>引用数据类型：</strong></p>
<ol>
<li><strong>Object：</strong> 表示对象，是一种键值对的集合。</li>
<li><strong>Array：</strong> 表示数组，可以存储多个值。</li>
<li><strong>Function：</strong> 表示函数。</li>
<li><strong>Date：</strong> 表示日期和时间。</li>
<li><strong>RegExp：</strong> 表示正则表达式。</li>
</ol>
</blockquote>
<h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><p> 解释浏览器的同源策略、JSONP、CORS、代理等跨域解决方案。</p>
<blockquote>
<p><strong>同源策略：</strong><br>同源策略是浏览器的一种安全策略，它限制了一个页面从一个源加载的文档或脚本如何与来自其他源的资源进行交互。同源是指协议、域名和端口都相同。</p>
<p><strong>JSONP（JSON with Padding）：</strong><br>JSONP是一种解决跨域访问的方法，它利用<code>&lt;script&gt;</code>标签的跨域能力来实现。通过动态创建<code>&lt;script&gt;</code>标签，将要获取的数据包装在一个回调函数中，让服务器返回调用该回调函数的脚本，从而实现跨域请求。</p>
<p><strong>CORS（跨源资源共享）：</strong><br>CORS是一种官方支持的跨域解决方案。它通过在HTTP头部添加一些特定的头字段来允许服务器声明哪些来源被允许访问资源。前端发起跨域请求时，浏览器会自动发送CORS预检请求，如果服务器返回合适的CORS头部，浏览器允许跨域访问。</p>
<p><strong>代理：</strong><br>代理是一种通过在同源服务器上创建一个中间层来转发请求和响应的方法。前端通过访问同源服务器，然后由服务器代理请求真正的目标服务器，再将响应返回给前端，实现跨域访问。</p>
<p>这些跨域解决方案各有优缺点：</p>
<ul>
<li><strong>JSONP：</strong> 适用于GET请求，安全性较差，只能实现一些简单的跨域需求。</li>
<li><strong>CORS：</strong> 支持各种HTTP请求，更加安全可靠，但需要服务器端配合设置CORS头部。</li>
<li><strong>代理：</strong> 适用于所有请求，但需要同源服务器支持和维护。</li>
</ul>
<p>选择合适的跨域解决方案取决于项目的需求和实际情况。</p>
</blockquote>
<h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p> 解释JavaScript中的面向对象特性，如对象、类、构造函数、继承等。</p>
<blockquote>
<p>JavaScript是一门基于原型的面向对象编程语言，它的面向对象特性包括以下几个重要概念：</p>
<p><strong>1. 对象：</strong> 对象是JavaScript中的基本数据结构，可以存储属性和方法。属性可以是基本类型或其他对象，方法是一组可以被调用的函数。对象是按照键值对的方式组织属性和方法的。</p>
<p><strong>2. 构造函数：</strong> 构造函数是用于创建对象的特殊函数，通过<code>new</code>关键字调用。构造函数可以被看作是创建对象的蓝图，它定义了对象的属性和方法。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello, my name is Alice</span></span><br><span class="line">person2.<span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello, my name is Bob</span></span><br></pre></td></tr></table></figure></div>

<p><strong>3. 原型（Prototype）：</strong> 每个JavaScript对象都有一个原型对象，它允许对象继承属性和方法。构造函数的<code>prototype</code>属性指向原型对象，而对象通过<code>__proto__</code>属性访问原型。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Dog</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Dog</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bark</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> is barking`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog1 = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;Buddy&quot;</span>);</span><br><span class="line">dog1.<span class="title function_">bark</span>(); <span class="comment">// 输出：Buddy is barking</span></span><br></pre></td></tr></table></figure></div>

<p><strong>4. 继承：</strong> 通过原型链，JavaScript实现了原型继承。一个对象可以从另一个对象继承属性和方法。子类对象的原型指向父类对象，从而实现继承。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, grade</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Student</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Eva&quot;</span>, <span class="number">5</span>);</span><br><span class="line">student1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出：Hello, my name is Eva</span></span><br></pre></td></tr></table></figure></div>

<p>JavaScript的面向对象特性基于原型机制，它的灵活性和动态性使得对象可以在运行时进行扩展和修改。虽然与传统类和继承的面向对象语言有些不同，但JavaScript的面向对象编程是其重要的编程范式之一。</p>
</blockquote>
<h4 id="定时器和事件循环"><a href="#定时器和事件循环" class="headerlink" title="定时器和事件循环"></a>定时器和事件循环</h4><p> 解释<code>setTimeout</code>、<code>setInterval</code>以及<code>requestAnimationFrame</code>的使用，理解事件循环的机制。</p>
<blockquote>
<p><strong><code>setTimeout</code>和<code>setInterval</code>的使用：</strong></p>
<p>这两个函数都是用于在一段时间后执行代码或重复执行代码。</p>
<ol>
<li><p><strong><code>setTimeout</code>：</strong></p>
<ul>
<li><code>setTimeout</code>函数用于在一定时间后执行一次指定的函数。</li>
<li>语法：<code>setTimeout(function, delay)</code></li>
<li>第一个参数是要执行的函数，第二个参数是延迟的毫秒数。</li>
<li>示例：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Delayed log after 1000ms&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><strong><code>setInterval</code>：</strong></p>
<ul>
<li><code>setInterval</code>函数用于在一定时间间隔内重复执行指定的函数。</li>
<li>语法：<code>setInterval(function, delay)</code></li>
<li>第一个参数是要执行的函数，第二个参数是时间间隔的毫秒数。</li>
<li>示例：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Repeated log every 2000ms&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
<p><strong><code>requestAnimationFrame</code>的使用：</strong><br><code>requestAnimationFrame</code>是用于在浏览器下一次重绘之前执行指定的函数，通常用于制作动画。</p>
<ul>
<li><code>requestAnimationFrame</code>会根据浏览器的绘制周期自动调用函数，通常与递归结合，创建平滑的动画效果。</li>
<li>语法：<code>requestAnimationFrame(callback)</code></li>
<li>示例：<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params">timestamp</span>) &#123;</span><br><span class="line">  <span class="comment">// 执行动画逻辑</span></span><br><span class="line">  <span class="comment">// 在下一次重绘前调用自身</span></span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(animate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(animate);</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><strong>事件循环的机制：</strong><br>事件循环是JavaScript异步执行的基础。在浏览器环境中，JavaScript运行在单线程中，通过事件循环机制来处理异步任务，以避免阻塞主线程。</p>
<p>事件循环的基本流程：</p>
<ol>
<li>从消息队列中获取任务，将其添加到调用栈（执行栈）中执行。</li>
<li>如果调用栈为空，从消息队列中取下一个任务，执行之。</li>
<li>重复步骤1和2，直至消息队列为空。</li>
</ol>
<p>事件循环机制保证了异步任务（如<code>setTimeout</code>、网络请求、事件处理等）能够按照顺序执行，避免了阻塞主线程。<code>setTimeout</code>和<code>setInterval</code>将任务放入消息队列，而<code>requestAnimationFrame</code>则在浏览器下一次绘制前调用函数，确保动画平滑执行。</p>
</blockquote>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p> 了解如何优化JavaScript性能，包括减少重绘回流、懒加载、代码分割等。</p>
<blockquote>
<p>优化JavaScript性能是确保网页快速加载和响应的关键。以下是一些优化技巧，包括减少重绘回流、懒加载、代码分割等：</p>
<p><strong>1. 减少重绘和回流：</strong></p>
<ul>
<li>使用CSS Transitions 和 CSS Animations 来代替使用 JavaScript 实现的动画效果，因为 CSS 动画在绘制上更高效。</li>
<li>避免频繁地修改DOM样式和布局属性，可以使用类名一次性修改多个属性。</li>
<li>使用<code>transform</code>属性进行位移、旋转和缩放，因为它不会引起回流。</li>
</ul>
<p><strong>2. 懒加载（Lazy Loading）：</strong></p>
<ul>
<li>对于图片、视频等资源，使用懒加载技术来延迟加载这些内容，直到用户滚动到它们附近。</li>
<li>使用<code>&lt;img&gt;</code>的<code>loading=&quot;lazy&quot;</code>属性来实现图片的懒加载。</li>
</ul>
<p><strong>3. 代码分割（Code Splitting）：</strong></p>
<ul>
<li>将应用拆分成多个模块或chunk，只加载当前页面所需的代码，从而加速初始加载时间。</li>
<li>使用工具（如Webpack）来自动进行代码分割，确保按需加载模块。</li>
</ul>
<p><strong>4. 压缩和混淆：</strong></p>
<ul>
<li>压缩JavaScript、CSS和HTML文件，减少文件大小，加快加载速度。</li>
<li>使用工具（如Terser）来进行JavaScript的代码混淆，减少不必要的代码和变量名。</li>
</ul>
<p><strong>5. 避免不必要的HTTP请求：</strong></p>
<ul>
<li>将多个小的文件合并成一个大文件，减少HTTP请求次数。</li>
<li>使用CSS Sprites将多个小图标合并成一个图片，减少加载时间。</li>
</ul>
<p><strong>6. 缓存机制：</strong></p>
<ul>
<li>使用浏览器缓存，将资源缓存在用户本地，提高再次访问速度。</li>
<li>设置适当的缓存头部，例如使用<code>Cache-Control</code>和<code>Expires</code>。</li>
</ul>
<p><strong>7. 使用Web Workers：</strong></p>
<ul>
<li>使用Web Workers在后台线程中处理一些耗时的任务，避免阻塞主线程，提升页面的响应性能。</li>
</ul>
<p><strong>8. 优化图片和媒体资源：</strong></p>
<ul>
<li>使用适当的图片格式，如JPEG、PNG、WebP，以及压缩工具来优化图片大小。</li>
<li>对图片进行懒加载，仅在它们进入视口时加载。</li>
</ul>
<p><strong>9. 避免同步请求：</strong></p>
<ul>
<li>避免在主线程中执行耗时的同步请求，使用异步请求（如XMLHttpRequest、Fetch API）。</li>
</ul>
<p>综合使用这些优化技巧，可以显著提升网页的性能，使用户体验更加流畅。然而，需要根据具体的项目情况进行评估和优化。</p>
</blockquote>
<h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>例如实时监控用户输入的时候，为防止用户输入每个字符都要进行监控操作（发请求、校验等等），可以设置定时器使用户在输入完成之后再进行下一步操作，达到防抖效果，如下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay</span>) &#123;  <span class="comment">// 定义一个debounce函数，传入操作函数和延迟时间</span></span><br><span class="line">	<span class="keyword">let</span> timer = nul</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)    <span class="comment">// 如果有定时器就重置</span></span><br><span class="line">		timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>) <span class="comment">// apply 改变 this 指向，使调用者的this能够指向input</span></span><br><span class="line">		&#125;, delay)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	input.<span class="title function_">addEventListener</span>(   <span class="comment">// 设置一个input的事件监听</span></span><br><span class="line">	<span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">	<span class="title function_">debounce</span>(<span class="keyword">function</span> (<span class="params">event</span>) &#123; <span class="comment">// 不使用箭头函数也是为了能够正确拿到this和event对象</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(event)</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;发送请求&#x27;</span>)</span><br><span class="line">	&#125;, <span class="number">500</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>



<h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节流：一段时间内，只执行一次某个操作；过了这段时间，还有操作的话，继续执行新的</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay</span>) &#123;</span><br><span class="line">	<span class="keyword">let</span> timer = nu</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (timer) <span class="keyword">return</span>		<span class="comment">// 如果timer还有的话，就不触发事件</span></span><br><span class="line">		timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">			fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">			timer = <span class="literal">null</span>	<span class="comment">// timer置空使delay过了之后又可以执行fn()</span></span><br><span class="line">		&#125;, delay)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">box.<span class="title function_">addEventListener</span>(</span><br><span class="line">	<span class="string">&#x27;drag&#x27;</span>,</span><br><span class="line">	<span class="title function_">throttle</span>(<span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">		<span class="comment">// console.log(event.offsetX, event.offsetY)</span></span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">	&#125;, <span class="number">300</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>



<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>Promise是JavaScript中处理异步操作的一种机制，用于更优雅地管理异步代码和处理回调地狱（callback hell）问题。它提供了一种更结构化和可读性更高的方式来处理异步操作，以及在操作完成后获取结果或处理错误。</p>
<p>Promise的基本概念如下：</p>
<ul>
<li><p><strong>Pending（进行中）：</strong> Promise对象的初始状态，表示异步操作尚未完成。</p>
</li>
<li><p><strong>Fulfilled（已完成）：</strong> 表示异步操作成功完成，此时会调用<code>then</code>方法中的回调函数，获取操作结果。</p>
</li>
<li><p><strong>Rejected（已拒绝）：</strong> 表示异步操作失败，此时会调用<code>catch</code>方法中的回调函数，处理错误。</p>
</li>
</ul>
<p>Promise的基本用法示例：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myPromise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 异步操作</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 操作成功 */</span>) &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&quot;操作成功的结果&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&quot;操作失败的原因&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myPromise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功：&quot;</span> + result);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;失败：&quot;</span> + error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></div>

<p>Promise的原理可以简要概括如下：</p>
<ol>
<li><p><strong>Promise的构造：</strong> 创建一个Promise对象时，会传入一个执行器函数，这个函数接受两个参数：<code>resolve</code>和<code>reject</code>。在异步操作完成时，调用<code>resolve</code>表示操作成功，调用<code>reject</code>表示操作失败。</p>
</li>
<li><p><strong>状态的改变：</strong> 在执行器函数中，调用<code>resolve</code>或<code>reject</code>会改变Promise的状态，从Pending变为Fulfilled或Rejected。</p>
</li>
<li><p><strong>then和catch方法：</strong> Promise提供了<code>then</code>和<code>catch</code>方法来处理操作成功和操作失败的情况。<code>then</code>方法接受一个成功回调函数，<code>catch</code>方法接受一个失败回调函数。</p>
</li>
<li><p><strong>链式调用：</strong> 通过返回新的Promise，可以实现链式调用。这使得可以在不同的步骤中串联处理多个异步操作。</p>
</li>
<li><p><strong>解决回调地狱：</strong> 使用Promise可以更清晰地组织异步代码，避免多层嵌套的回调函数，提高了代码的可读性和维护性。</p>
</li>
</ol>
<p>需要注意的是，虽然Promise可以解决回调地狱问题，但在复杂的异步场景下，仍然可能导致代码难以理解。为了进一步简化异步代码，ES6引入了<code>async/await</code>语法，可以更直观地编写异步代码，基于Promise实现。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是JavaScript中的一个重要概念，它涉及作用域和函数的关系，通常用来描述函数内部可以访问外部作用域的情况。一个闭包是由函数以及声明在该函数内部的所有变量组成的，这些变量可以继续在函数执行完毕后被访问。</p>
<p>简单地说，闭包就是一个函数，它可以访问它被创建时所处的词法作用域中的变量，即使这个函数在不同的作用域中被调用。闭包在处理一些高级的编程模式和异步编程时非常有用。</p>
<p>以下是闭包的一些关键特点：</p>
<ol>
<li><p><strong>函数嵌套：</strong> 闭包通常是由一个函数内部定义另一个函数所创建的。内部函数可以访问外部函数中的变量和参数，即使外部函数已经执行完毕。</p>
</li>
<li><p><strong>变量的引用：</strong> 内部函数持有外部函数作用域的引用，使得外部函数中的变量不会被垃圾回收，直到内部函数不再被引用为止。</p>
</li>
<li><p><strong>保护状态：</strong> 闭包可以被用于保护变量状态，防止外部访问或修改，实现了数据的私有性。</p>
</li>
<li><p><strong>实现数据封装：</strong> 闭包可以将变量封装在函数内部，只暴露特定的接口来访问和操作变量，实现了信息隐藏。</p>
</li>
<li><p><strong>异步编程：</strong> 在异步编程中，闭包可以解决回调函数无法访问正确作用域的问题。例如，在事件处理函数中使用闭包来访问外部函数的变量。</p>
</li>
</ol>
<p>以下是一个简单的闭包示例：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">outerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> outerVar = <span class="string">&quot;I&#x27;m outside!&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVar); <span class="comment">// 内部函数可以访问外部函数的变量</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> innerFunction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closure = <span class="title function_">outerFunction</span>(); <span class="comment">// 返回内部函数，形成闭包</span></span><br><span class="line"><span class="title function_">closure</span>(); <span class="comment">// 调用内部函数，输出 &quot;I&#x27;m outside!&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>需要注意的是，虽然闭包非常有用，但过多地使用闭包可能导致内存占用和性能问题。因为闭包会持有外部作用域的引用，当闭包在不再需要的时候，需要手动解除引用，以便垃圾回收可以释放内存。在使用闭包时，需要权衡性能和内存消耗。</p>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>作用域（Scope）是指变量和函数在代码中的可访问范围。在JavaScript中，作用域决定了哪些变量和函数可以在哪里被访问，以及它们是否可见。JavaScript采用词法作用域（也称为静态作用域），意味着作用域在代码编写时就确定了，而不是在运行时确定。</p>
<p>作用域链（Scope Chain）是指由嵌套的函数作用域所构成的一条链，它决定了一个变量在哪个作用域中被查找和访问。作用域链的顶端是当前函数的作用域，然后逐级往上查找，直到全局作用域为止。</p>
<p>以下是一些关键概念和解释：</p>
<ol>
<li><p><strong>全局作用域：</strong> 在最外层定义的变量和函数具有全局作用域，可以在任何地方访问。</p>
</li>
<li><p><strong>函数作用域：</strong> 函数内部定义的变量和函数具有函数作用域，只能在该函数内部访问。</p>
</li>
<li><p><strong>块级作用域：</strong> 由ES6引入，用于控制if语句、循环等块中定义的变量的作用范围。</p>
</li>
<li><p><strong>作用域链的建立：</strong> 当访问一个变量时，JavaScript引擎首先在当前作用域中查找，如果找不到则继续向上一级作用域查找，直到全局作用域。</p>
</li>
<li><p><strong>闭包中的作用域链：</strong> 在一个函数内部定义的函数可以访问外部函数的作用域，形成了闭包。这就是闭包的作用域链。</p>
</li>
<li><p><strong>变量提升：</strong> 在一个作用域中，变量声明会被提升到作用域的顶部，但赋值不会。这意味着你可以在声明前使用变量，但它的值将是<code>undefined</code>。</p>
</li>
</ol>
<p>以下是一个简单的作用域和作用域链示例：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> globalVar = <span class="string">&quot;Global&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> outerVar = <span class="string">&quot;Outer&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> innerVar = <span class="string">&quot;Inner&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(innerVar); <span class="comment">// 在内部函数中访问内部变量</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(outerVar); <span class="comment">// 在内部函数中访问外部函数作用域的变量</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(globalVar); <span class="comment">// 在内部函数中访问全局变量</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure></div>

<p>理解作用域和作用域链是理解JavaScript中变量访问和作用域限制的关键。它对于理解闭包、函数嵌套以及变量的可见性和生命周期等概念非常重要。</p>
<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p><strong>原型（Prototype）：</strong><br>在JavaScript中，每个对象都有一个原型，它是一个对象，用于存储共享的属性和方法。当你访问一个对象的属性或方法时，如果对象本身没有这个属性或方法，JavaScript会沿着原型链查找，找到原型对象上的对应属性或方法。原型是一个对象与对象之间的关系，它通过引用连接在一起。</p>
<p><strong>原型链（Prototype Chain）：</strong><br>原型链是由一系列的原型对象组成的链式结构，用于属性和方法的查找。当访问一个对象的属性或方法时，JavaScript引擎会首先在对象自身查找，如果找不到，则沿着原型链向上一级的原型对象查找，直到找到属性或方法或者到达原型链的顶端（<code>Object.prototype</code>）。</p>
<p>以下是原型和原型链的一些关键点：</p>
<ol>
<li><p><strong>原型对象的创建：</strong> 在JavaScript中，每个函数都有一个<code>prototype</code>属性，指向一个原型对象。这个原型对象可以包含共享的属性和方法。</p>
</li>
<li><p><strong>实例对象和原型的关系：</strong> 当通过一个构造函数创建对象实例时，实例会继承构造函数的原型对象上的属性和方法。这使得对象实例可以共享相同的属性和方法。</p>
</li>
<li><p><strong>原型链的构建：</strong> 当访问一个对象的属性或方法时，JavaScript引擎会先在对象自身查找，如果找不到，它会向上一级的原型对象查找，依此类推，直到找到或到达原型链的顶端。</p>
</li>
<li><p><strong>Object.prototype：</strong> 原型链的顶端是<code>Object.prototype</code>，它是所有对象的原型。它包含JavaScript内置的一些方法，如<code>toString</code>、<code>hasOwnProperty</code>等。</p>
</li>
<li><p><strong>属性查找顺序：</strong> 原型链的属性查找是从下到上的，即先在对象自身查找，然后再在原型对象上查找，以此类推。</p>
</li>
</ol>
<p>以下是一个简单的原型和原型链示例：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加原型方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello, I&#x27;m &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用实例方法</span></span><br><span class="line">person1.<span class="title function_">sayHello</span>(); <span class="comment">// 输出 &quot;Hello, I&#x27;m Alice&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找属性和方法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>); <span class="comment">// 从实例中查找 &quot;name&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayHello</span>); <span class="comment">// 从原型对象中查找 &quot;sayHello&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>理解原型和原型链是理解JavaScript中对象继承的基础。它对于理解构造函数、继承模式以及面向对象编程在JavaScript中的实现方式非常重要。</p>
<h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><p>在面试中，ES5（ECMAScript 5）和ES6（ECMAScript 2015，也称为ES2015或ES6）都是常见的考点，因为它们是JavaScript语言中的两个重要版本，带来了许多新的语法、特性和改进。以下是在面试中可能涉及到的一些ES5和ES6的考点：</p>
<p><strong>ES5 考点：</strong></p>
<ol>
<li><p><strong>变量声明：</strong> 包括使用<code>var</code>、<code>let</code>、<code>const</code>进行变量声明的区别、作用域等。</p>
</li>
<li><p><strong>函数：</strong> 包括函数声明和函数表达式的区别、函数作用域、闭包、<code>arguments</code>对象等。</p>
</li>
<li><p><strong>作用域和闭包：</strong> 解释作用域链、闭包的概念和原理，以及如何避免闭包引发的内存泄漏。</p>
</li>
<li><p><strong>原型和原型链：</strong> 解释原型、原型链的概念，以及如何实现继承。</p>
</li>
<li><p><strong>同步和异步：</strong> 解释回调函数、事件循环、异步编程等。</p>
</li>
<li><p><strong>事件处理：</strong> 解释事件冒泡和事件捕获机制，以及如何添加和移除事件监听器。</p>
</li>
</ol>
<p><strong>ES6 考点：</strong></p>
<ol>
<li><p><strong>let 和 const：</strong> 解释<code>let</code>和<code>const</code>关键字，以及它们与<code>var</code>的区别，包括块级作用域等。</p>
</li>
<li><p><strong>箭头函数：</strong> 解释箭头函数的特性，以及它与普通函数的区别。</p>
</li>
<li><p><strong>模板字符串：</strong> 解释模板字符串的语法和用法，包括插值、多行字符串等。</p>
</li>
<li><p><strong>解构赋值：</strong> 解释解构赋值的概念和用法，包括数组和对象的解构。</p>
</li>
<li><p><strong>展开运算符：</strong> 解释展开运算符的用法，包括在数组、对象和函数调用中的应用。</p>
</li>
<li><p><strong>类和继承：</strong> 解释ES6中的类和继承，以及与ES5原型继承的区别。</p>
</li>
<li><p><strong>Promise 和异步编程：</strong> 解释Promise的概念、用法，以及如何处理异步编程。</p>
</li>
<li><p><strong>生成器和迭代器：</strong> 解释生成器函数和迭代器的概念，以及它们在异步编程中的应用。</p>
</li>
<li><p><strong>模块化：</strong> 解释ES6模块的语法和用法，包括导入和导出等。</p>
</li>
<li><p><strong>新的数据结构：</strong> 解释Set、Map、WeakSet、WeakMap等新的数据结构和用法。</p>
</li>
</ol>
<p>在面试中，了解这些ES5和ES6的知识点，以及它们的语法、特性和用法，会帮助你更好地回答相关问题，展现你的JavaScript编程能力。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>前端</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
